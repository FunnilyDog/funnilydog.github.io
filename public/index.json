


[{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/","section":"FunnilyDog‘s Site","summary":"","title":"FunnilyDog‘s Site","type":"page"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/notes/","section":"Notes","summary":"","title":"Notes","type":"notes"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":" pnpm npm yarn # pnpm 通过硬链接、冗余移除、压缩存储、并行安装和锁定文件等机制，实现了高效、可共享的依赖管理方式，有效地减少了磁盘空间占用和重复下载的问题，并提高了安装速度\npnpm 使用符号链接 Symbolic link（软链接）来创建依赖项的嵌套结构，将项目的直接依赖符号链接到 node_modules 的根目录， 直接依赖的实际位置在.pnpm/@/node_modules/， 依赖包中的每个文件再硬链接（Hard link）到.pnpm store\nnpm yarn 会在每个 node_modules 目录为所有依赖项村粗完整文件副本，如果有相同依赖 则会被重复存储。 采用扁平依赖树来管理依赖包，解决依赖嵌套层级过深 以及重复安装 问题\nCommonjs(node) 和 es nodule 模块化 导入导出的区别 # CommonJs # 关键字：导入 require 导出 module.exports / exports 可以导出任意类型，为同步加载模块 因此不适用于浏览器（若某个模块加载很慢会导致页面假死）。 CommonJs如何避免循环导入： 首先加载之后的文件的 module 会被缓存到 Module 上，比如一个模块已经 require 引入了 a 模块，如果另外一个模块再次引用 a ，那么会直接读取缓存值 module ，所以无需再次执行模块 module.exports / exports 区别： 如果我们不想在 commonjs 中导出对象，而是只导出一个类或者一个函数再或者其他属性的情况，那么 module.exports 就更方便 exports 会被初始化成一个对象，也就是我们只能在对象上绑定属性 ES Module # 关键字: 导入 import 导出 export / export defult ES6 module 的引入和导出是静态的,可导出任意类型，可默认导出某个属性，导入导出时可用 as 关键字 重命名 导入导出属性。也可用于node 模块化 ES Module 避免循环依赖： ES Module借助模块地图，已经进入过的模块标注为获取中，遇到import语句会去检查这个地图，已经标注为获取中的则不会进入，地图中的每一个节点是一个模块记录，上面有导出变量的内存地址，导入时会做一个连接——即指向同一块内存。 import() 动态引入: import() 返回一个 Promise 对象， 返回的 Promise 的 then 成功回调中，可以获取模块的加载成功信息。 浏览器内核 # 渲染引擎 # 解析HTML、CSS Trident: IE浏览器、百度浏览器 Gecko: Firefox浏览器 Blink: Opera浏览器、Chrome浏览器、Edge浏览器 Webkit: Safari浏览器 解决渲染引擎引起的兼容问题：Normalize.css JS 引擎 # 常见引擎及所在浏览器 Chakra:微软开发，用于IE浏览器 JavaScriptCore:WebKit中的JavaScript引擎，Apple公司开发 V8:Google开发的强大JavaScript引擎，也帮助Chrome从众多浏览器中脱颖而出 v8引擎执行过程： 进行Parser (词法分析，语法分析)成抽象 AST 树 AST 通过 Ignition（理解成解释器或者转化器）生成 bytecode(字节码)，js 实现跨平台的关键点 最后根据运行环境，自动将字节码转成对应的汇编代码-\u0026gt;机器码，由 CPU 执行 垃圾回收机制 # 浏览器垃圾回收机制 # 引用计数: 跟踪记录每个引用类型被使用的次数，赋值+1，变更-1，当引用计数为 0 时被回收\n弊端：循环引用将不可被清除、需要开辟新内存存储引用计数\n标记清除： 为程序中所有的变量添加上一个二进制字符(二进制运算最快)并初始值置为 0(默认全是垃圾)，然后遍历所有的对象，被使用的变量标记置为 1，所有被标记置为 1 的变量所引用的变量也置为 1，在程序运行结束时回收掉所有标记为零的变量，回收结束之后将现存变量标记统一置为 0，等待下一轮回收开启。\n弊端：耗时，产生内存碎片\nV8 垃圾回收优化 # 分代式 # V8 将内存空间划分为 新生代 和 老生代 . 新生代存储新产生的(存活时间较短)较小的对象，其内存空间通常只有 1 ～ 8M . 新生代会被拆分为使用区和空闲区，新的对象都会被分配到使用区，当使用区快满时则进行新生代区域的垃圾回收： 对使用区的活动对象进行标记，标记完成后将活跃对象复制到空闲区并排序，随后对使用区进行清理，最后将使用区与空闲区对换。\n· 当一个对象被多次复制还未被清理掉，故此对象会被认定为生命周期较长的对象，会被从新生代移动到老生代中 · 老生代存储着较大或生命周期较长的对象，对老生代垃圾回收则使用标记整理算法\n优化 # \u0026ndash; V8 在垃圾回收时会同时开启多个辅助线程进行并行回收 \u0026ndash; V8 会在标记阶段采用三色标记法进行切片处理（标记开始时所有对象都为白色，从跟对象开始将可达位置标记为灰色，若中断标记，后续直接从灰色继续开始同时将灰色置为黑色同时将下一代对象置为灰色，直至无可标记为灰色对象为止便 开始清除），为保障切片过程中已标记过的对象产生的新对象未被标记，会强制判断一旦有黑色的对象引用白色的对象，就会强制将被引用的白色变量标记为灰色。\n\u0026ndash; V8 标记完成后，如果内存足够便不会立即进行清理。\nMVVM MVC MVP # MVC # . Model: 主要管理业务模型的数据和行为，它既保存程序的数据，也定义了处理该数据的逻辑 . View: 接收用户的交互请求并展示数据信息给用户 . Controller: View 接收到用户的交互请求之后，会将请求转发给 Controller， Controller 解析用户的请求之后，就会交给对应的 Model 去处理 MVP # 三件套各自的职责和依赖关系和变种 MVC 里的职责和依赖关系其实是一样的， 但不同的是，MVP 之间的交互主要是通过接口实现的，Model、View、Presenter 都有各自的接口，降低模块之间的耦合性，便于进行单元测试了，维护性和扩展性也提高了。 但是 需要编写的代码量变多，需要对业务模块之前的交互抽象成借口定义，对开发的设计能力要求高。 MVVM # MVVM 最重要的一个特性就是数据绑定，通过将 View 的属性绑定到 ViewModel， 可以使两者之间松耦合，也完全不需要在 ViewModel 里写代码去直接更新一个 View . ViewModel: 视图模型，封装的是视图的表示逻辑和数据， 是对视图的抽象，包括视图的属性和命令，或视图的状态和行为。 总结: MVP 和 MVVM 都是为了解决界面和数据的分离问题，两者只是采用了不同的实现方案。 MVP 之间的交互主要是通过接口实现的，其主要弊端就是需要编写大量接口。 MVVM 则是通过数据绑定的方式实现交互，虽然其实现需要依赖具体的一些框架工具， 但明显大大减少了开发者需要编写的代码量。\nTree Shakig # 利用es module 静态引用的特性，在打包时从entry入口出发扫描所有依赖形成抽象语法树，随后运行所有代码，并打标，最后将没有被用到的代码消除掉。 jwt 实现 登录 tooken # jwt(JSON Web Token) 是一种开放标准，用于在各方之间安全传输信息。主要用于身份验证和授权。\nJWT 组成： 头部、负载、签名三部分，之间用.分割。 # 头部：主要描述 JWT 的元数据，包括令牌类型，加密算法等。 负载：数据声明部分，主要包含用户或其他实体信息，如 用户 id，用户名等。有 3 种声明类型：注册声明（JWT 规范中预定义的声明），公共声明（用户自定义的声明），私有声明（使用 JWT 的双方共享的自定义声明） 签名：签名是用于验证消息在传递过程中没有被篡改。它是通过头部中指定的签名算法，对编码后的头部和编码后的负载进行签名计算得到的 JWT 登录鉴权 # 用户输入账号密码信息 服务器验证信息是否正确，返回已签名token（JWT） 将token存储在客户端（local storage）/ cookie 在之后的HTTP请求中将token添加到请求头（一般为Authorazation） 服务器解码JWT，有效则接受请求。 ","date":"2025-01-19","externalUrl":null,"permalink":"/notes/engineer/","section":"Notes","summary":"记录 整理遇到的八股文知识点之 工程化篇","title":"八股文 -- 工程化","type":"notes"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/series/%E5%85%AB%E8%82%A1%E6%96%87-%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/","section":"Series","summary":"","title":"八股文 查缺补漏","type":"series"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/tags/docker/","section":"Tags","summary":"","title":"Docker","type":"tags"},{"content":" 安装nginx # \u0026ndash; docker pull nginx\n","date":"2025-01-19","externalUrl":null,"permalink":"/hugo/config/","section":"Hugoes","summary":"docker 部署 静态网站之","title":"docker 运行配置 nginx","type":"hugo"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/tags/http/","section":"Tags","summary":"","title":"Http","type":"tags"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/hugo/","section":"Hugoes","summary":"","title":"Hugoes","type":"hugo"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/tags/javascript/","section":"Tags","summary":"","title":"Javascript","type":"tags"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/tags/nginx/","section":"Tags","summary":"","title":"Nginx","type":"tags"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/tags/notes/","section":"Tags","summary":"","title":"Notes","type":"tags"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" url uri urn # URI 语法：scheme:[//[user:password@]host[:port]][/]path[?query][#fragment] Scheme：URI 的起始点，并与 URI 协议相关。URI schema 对大小写不敏感，后面带有一个“:”。几个流行的 URI schema 的例子：HTTP、HTTPS、FTP 和 mailto。 Authority（权限）：Authority 字段是位于 schema 字段之后的第二个条目，以两个斜杠(//)开头。这个字段由多个子字段组成： • authentication（认证信息）-可选的字段和用户名，密码，由冒号隔开，后面跟着“@”符号 • host（主机名）—注册的名称或 IP 地址，出现在“@”符号之后 • port（端口号）-可选字段，后面跟着一个冒号 Path（路径）：Path 是第三个字段，由斜杠分隔的段序列来表示，用来提供资源的位置。注意，不管 authority 部分存在或不存在，path 都应该以一个斜杠开始，而不是双斜杠(//)。 Query（查询）：Query 是第四个字段，是 URI 的可选字段，包含一串非结构数据并以“?”和 Path 隔开。 Fragment（片段）：Fragment 是第五个组成部分，也是一个可选字段，提供指向辅助资源的方向，并以“#”开始。简单来说，Fragment 字段可以用于指向 HTML 页面的特定元素(主资源)。\nurl（统一资源定位符），用于标示网络资源的位置。URL 是一个给定唯一 Web 资源的地址，表明了这个唯一的 Web 资源的位置，用户可以通过 URL 浏览互联网。如果我们在任何应用程序中点击任何超链接，它会将我们重定向到相关的 URL，这些 URL 也可以很容易的输入到浏览器地址栏中，并可以加载特定的资源。\nURN 是一种具有静态名称的互联网资源，即使它的数据被移动到另一个位置也仍然有效。URL 在内容被移动后就失效了，与之不同的是，URN 可以始终跟踪 Web 上某些数据的资源，从而解决了频繁移动数据的问题。 URN 语法：scheme:NID: NSS\nhttp https # http 1.0 # 无状态、无连接的应用层协议，一次只能发出一个未完成的请求\nhttp1.1 # \u0026ndash; 基于 connection：keep-alive 建立持久链接， \u0026ndash; 基于管道可以一次发出多个请求，但服务端依旧需要按顺序响应。 \u0026ndash; 新增 身份认证、缓存等机制相关的请求头。 \u0026ndash; HTTP1.1 的请求消息和响应消息都应支持 Host 头域\nhttp2.0 # \u0026ndash; 采用二进制消息帧，建立请求优先级 帧(frame)包含部分：类型 Type, 长度 Length, 标记 Flags, 流标识 Stream 和 frame payload 有效载荷 消息(message)：一个完整的请求或者响应，比如请求、响应等，由一个或多个 Frame 组成。\n\u0026ndash; 多路复用 请求响应都采用流式数据在同一个 tcp 通道内传输，通过 流标识 进行同一个 请求响应 的匹配。 \u0026ndash; 头部压缩 http2.0 头部也采用二进制数据格式，利用 HPACK 压缩算法（维护一张 header 字段表，利用索引代替实际 header） \u0026ndash; 服务器推送 服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确地请求\nhttp3.0 # \u0026ndash; 采用 QUIC 协议（基于 UDP） 解决了 TCP 协议 头包丢失导致的阻塞问题\nhttp 缓存 # 强缓存：浏览器会检测缓存时间是否过期，若未过期则不会向服务器发请求转而直接从缓存中读取。 在 http1.1 后改由请求头 cache-control 中的 max-age 控制。 命中强缓存 状态码返回 200 size 为 form disk cache / memory cache。\n协商缓存：浏览器优先检测是否命中强缓存，若未命中强缓存则浏览器携带协商缓存标识向服务器发起请求，由服务器根据缓存标识确定是否使用缓存，若生效则返回状态码 304，否则正常返回 200 和请求资源。 缓存是否失效 由 Last-Modified / If-Modified-Since 和 ETag 决定。 浏览器首次请求资源时服务器会在响应头中给到 Last-Modified ，浏览器再次请求该资源时 会在请求头中添加 If-Modified-Since 由服务器判断缓存资源是否失效。 由于 Last-Modified 只能精确到秒级，可能会导致已失效缓存被误判，且如果本地打开缓存文件也会更新 Last-Modified 。因此 Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag 就会重新生成。\najax fetch # ajax # const xhr = new XMLHttpRequest(); // 创建 xhr 操作对象 readyState = 0 xhr.open(\u0026#34;get\u0026#34;, \u0026#34;http://jsonplaceholder.typicode.com/posts/2\u0026#34;); // 建立请求 readyState = 1 xhr.setRequestHeader(\u0026#34;name\u0026#34;, \u0026#34;123\u0026#34;); xhr.send(/\\*_ 请求体可以放这里 _/); // 发送请求 readyState = 2 xhr.onreadystatechange = () =\u0026gt; { // readyState = 3 说明正在接收服务器传来的 body 部分的数据 if (xhr.readyState === 4 \u0026amp;\u0026amp; xhr.status === 200) { // readyState = 4 说明数据完全接收 console.log(xhr.response); } }; xhr.onprogress = (p) =\u0026gt; { if (p.lengthComputable) { // 表示底层流程将需要完成的总工作量和已经完成的工作量是否可以计算 console.log(p.total); // 表示正在执行的底层流程的工作总量 console.log(p.loaded); // 表示底层流程已经执行的工作总量 } }; fetch # \u0026ndash; 请求实例\nfetch(\u0026#34;http://jsonplaceholder.typicode.com/posts\u0026#34;, { //请求方法 method: \u0026#34;POST\u0026#34;, //请求头 headers: { name: \u0026#34;zhang\u0026#34; }, //请求体 body: JSON.stringify({ id: 1 }) }) .then((response) =\u0026gt; { return response.json(); }) .then((response) =\u0026gt; { console.log(response); }); \u0026ndash; 中断请求：\nconst controller = new AbortController(); const { signal } = controller; fetch(\u0026#34;http://\u0026#34;, { signal }); controller.abort(); 区别 # \u0026ndash; fetch 使用 promise、 XMLHttpRequest 则使用回调的方式(需要开发手动包装 promise) \u0026ndash; fetch 只有在中断请求或网络故障或配置错误时才会被标记 reject，其他时候都是 resolve；XHR 则需要在 onReadyStateChange 回调里自行判断 \u0026ndash; XHR 拥有 onProgress 回调监控传输进度 \u0026ndash; fetch 将请求分成了多个模型（Request、Responce、Headers）; XMLHttpRequest 只有一个自己的实例。 \u0026ndash; fetch 通过数据流处理数据，可以分块读取；XMLHTTPRequest 对象不支持数据流，所有的数据必须放在缓存里，不支持分块读取，必须等待全部拿到后，再一次性吐出来\n跨域 # 什么是跨域： 请求 url 的协议 域名 端口 中任意一个与当前页面 url 不同即为跨域 原因： 浏览器的同源策略规定非同源请求不能被浏览器所接受以防止 xss csrf 攻击\n解决方案：\n跨域资源共享（CORS） # \u0026ndash; 简单请求 浏览器会自动带上 Origin 请求头 服务器端验证 Origin 在白名单内则返回时添加 Access-Control-Allow-Origin 响应头告诉浏览器 允许该 Origin 访问 简单请求判断标准： a. 请求方法为 GET、POST、HEAD b. 请求头只允许出现 CORS 安全规范定义的标头集合 c. 请求中没有使用 ReadableStream 对象\n\u0026ndash; 非简单请求则需要在正式发起请求前进行 OPTIONS 预请求，该请求携带 Origin、Access-Control-Request-Method、Access-Control-Request-Headers 等请求头以便服务器验证是否允许实际请求。\n代理服务器 # JSONP \u0026amp; window.name # Web 安全 # XSS（跨站脚本攻击） 原理： 向目标网站注入脚本以获取用户信息等。 分类： 存储型（向服务器发送攻击脚本，存储在服务器中，用户正常请求时受到攻击），反射型（恶意链接），基于 DOM 防御： 浏览器/服务器端做好特殊字符转换校验，重要 cookie 可设置 httpOnly 属性防止被窃取。利用 csp 禁止除安全脚本以外的脚本运行。\nCSRF(跨站请求伪造) 原理：诱导用户打开三方网站，利用用户的登录态发起跨站请求。 分类： 自动发起 Get 请求(利用 img 等 src 属性)\n\u0026lt;img src=\u0026#34;https://time.geekbang.org/sendcoin?user=hacker\u0026amp;number=100\u0026#34; /\u0026gt; 自动发起 Post 请求（利用隐藏表单自动提交 ）\n\u0026lt;script\u0026gt; document.getElementById (\u0026#39;hacker-form\u0026#39;).submit();\u0026lt;/script\u0026gt; 不良链接\n\u0026lt;img width=150 src=http://images.xuejuzi.cn/1612/1-161230185104_1.jpg\u0026gt;\u0026lt;/img\u0026gt; \u0026lt;a href=\u0026#34;https://time.geekbang.org/sendcoin?user=hacker\u0026amp;number=100\u0026#34; taget=\u0026#34;\\_bla 点击下载美女照片\u0026#34; 防御： 通过设置 Access-Control-Allow-Origin 不允许或只允许安全域名下发起请求 利用 cookie 的 SameSite 属性 禁止三方请求发送重要 cookie。 利用 token 验证是否为合法三方请求。\nCSP # 定义：CSP 是一种用于增强网站安全的策略，他通过限制网页内容的来源和执行的方式来减少恶意攻击。\n原理： · 服务器设置策略：服务器端通过相应头 content-security-policy / content-security-policy-report-only 来设置 CSP 策略。 · 浏览器执行策略：浏览器加载网页时，会根据服务器端返回的 csp 策略限制网页中各种资源的加载和执行，并阻止不符合策略的操作。 · 检查资源来源：浏览器会检查网页中所有资源的来源是否符合 CSP 策略中定义的规则，如果资源的来源于策略不匹配，浏览器组织加载该资源。 · 限制脚本执行：CSP 还可以通过禁止或限制内连脚本的执行来阻止 XSS 攻击。\n","date":"2025-01-19","externalUrl":null,"permalink":"/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","section":"Notes","summary":"记录 整理遇到的八股文知识点之 计算机网络篇","title":"八股文 -- 计算机网络","type":"notes"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/series/%E9%9D%A2%E7%AD%8B/","section":"Series","summary":"","title":"面筋","type":"series"},{"content":" 旷视-智能驾驶 二面 # 问项目 # 视频怎么逐帧播放 # 表达式转 json # 用户通过表达式配置图表需要渲染的数据筛选条件，转化成 json 向服务端请求数据\n怎么实现 配置 key 提示 # key 链路较深 名次较长 用户输入时 需要提示\n淘天-基础交易 # 实现一个链式调用方法 # 实现金额格式化方法 # 项目亮点 # 实现 useEffect # 函数组件 和 类组件 优缺点 # 函数组件没有 this ，相对类组件 更加独立 不需要继承 clas，更少的模版代码，复用性 与可维护性更强。\n京东科技 # 找出数组中唯一没有重复的项 # 打家劫舍 # diff 过程 # JSX 到 浏览器绘制 DOM 过程 # 讲项目 # 了解那些新技术 # 腾讯云 # react 原理 # 原生操作 DOM 和 React 操作 DOM 有什么区别 # JSX 转化逻辑 # JSX 在编译还是执行过程转化的 # 编译阶段通过 bable 插件 转化\nreact Diff 过程 # webpack 打包流程 # 浏览器渲染流程 # 重排重绘 怎么减少重排重绘 # 了解什么新技术 # 手写代码： 异步任务列表 并发控制 # 作业帮 # render 原理/ 流程 # render 触发条件 # diff 过程中 key 的作用 以及 key 的应用场景 # gui 渲染 # 从输入 url 到 页面绘制 # http1 与 http2 区别 # dom 渲染时 遇到 script 标签 处理逻辑 # 性能优化问题（做过哪些性能优化） # 用过哪些 webpack loader/plugins # 按需加载原理 # babel-plugin-import 在打包过程中检测 ast 中 对应组件引入位置 更改为 组件绝对路径以及对应样式文件的引入\nlazy 原理 # React.lazy() 的原理是基于 React Suspense API，它使用了 JavaScript 中的动态 import() 语法来实现组件的延迟加载。当一个组件被封装在 React.lazy() 中时，Webpack 会将该组件打包成一个单独的代码块（chunk），并且在需要时才会下载和执行这个代码块。 当渲染延迟加载的组件时，React.lazy() 首先检查是否已经加载了该组件所在的代码块。如果还没有加载，则 React.lazy() 返回一个 Promise，该 Promise 将在下载并执行组件代码块后 resolve 并返回加装好的组件。如果已经加载，则直接返回已加载的组件。\n猫眼 # eslint 原理 # 组件库 npm 包产物 # echart 实现原理 # 渲染流程 # \u0026ndash; 初始化：创建 ECharts 实例，初始化配置项和数据。 \u0026ndash; 数据处理：根据配置项和数据生成图表的内部数据结构。 \u0026ndash; 组件渲染：渲染各个组件，如图例、坐标轴、标题等。 \u0026ndash; 图表渲染：根据内部数据结构渲染图表。 \u0026ndash; 事件绑定：绑定交互事件，实现图表的交互功能。\ncanvas # 单元测试 有写过么 # 工程化了解哪些 # 重复数字字符串修改 n 次使之无重复 # eg：111222333 =》 1a12a23a3 // n=3\ncsrf 安全问题 # 长安 一面 # 性能指标 # 性能优化 # 自己实现一个埋点上报 sdk 的思路 # 埋点上报性能优化思路 # 图片请求（Image Beacon）：通过创建一个 Image 对象，将要上报的数据作为 URL 参数拼接到一个 1x1 像素的透明图片 URL 中，发送一个 GET 请求来触发上报。\nNavigator.sendBeacon()：Navigator.sendBeacon()方法允许在页面卸载时异步发送数据。它通常用于在页面关闭时进行最后的数据上报，以确保数据能够成功发送。\n招银网络科技 # 项目难点 # 常用的 hook # useCallBack useMemo # useEffect useLayoutEffect # h5 上拉刷新 下拉加载 怎么实现 # 性能埋点实现 # 页面太长 有什么优化手段 # 页面请求加载时间太长 有什么优化手段 # js 事件循环 # 浏览器插件 执行在哪儿 # vast # 重载 # function func\u0026lt;T\u0026gt;(val: T): T; function func\u0026lt;T\u0026gt;(val: [T, ...unknown[]]): T; function func() {} zustand 优点 # useSyncExternalStore react 中同步 setState # setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。\nsetState 的“异步”并不是内部异步代码实现的，其本身执行过程和代码是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致这两个场景下没法立马拿到更新后的值，形成了所谓的“异步”，但是我们还是可以通过 setState 的第二个参数，callback 函数去拿到更新后的值的。\nsetState 的批量更新优化机制是建立在“异步”（合成事件，钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新。在“异步”中，如果是对同一个 key 值进行多次 setState，批量更新策略会对其进行覆盖，只对最后一次 setState 进行更新。如果同时 setState 多个不同的 key 值，会先进行合并操作，再在最后一个 setState 进行更新。\nreact 事件机制 # 合成事件：react 会在事件冒泡到 document 时集中捕获，并进行规范化处理，使之在不同浏览器中具有一致性。同时 react 合成事件于原生事件并非一一印设，合成事件有自己的映射规则。\n流程：\n事件绑定：\nReact 初始化时，会在根节点上绑定原生事件 支持冒泡的事件，React 会同时绑定捕获阶段和冒泡阶段的事件；不支持冒泡的事件，React 则只绑定捕获阶段的事件 React 将事件分为三种优先级类型，在绑定事件处理函数时会使用不同的回调函数，但底层都是调用 dispatchEvent 函数 事件触发\n在触发事件之前，React 会根据当前实际触发事件的 DOM 元素找到其 Fiber 节点，向上收集同类型事件添加到事件队列中。 根据事件阶段（冒泡/捕获），来决定（顺序/倒序）遍历执行事件函数。 当调用 React 阻止冒泡方法时，就是把变量 isPropagationStopped 设置为一个返回 true 的函数，后续派发事件时只要代码判断时则执行函数结果为 true 则表示阻止冒泡，就不再走下面逻辑。 ","date":"2025-01-19","externalUrl":null,"permalink":"/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%BE%85%E6%95%B4%E7%90%86/","section":"Notes","summary":"","title":"面题 -- 待整理","type":"notes"},{"content":" 谷罗英 # HASH 表 # 以键值对形势存储数据，在哈希表中进行增删查改的时间复杂度都是 O(1) tree 遍历 # 广度优先遍历 function levelOrder(root: TreeNode | null): number[] { // 初始化队列，加入根节点 const queue = [root]; // 初始化一个列表，用于保存遍历序列 const list: number[] = []; while (queue.length) { let node = queue.shift() as TreeNode; // 队列出队 list.push(node.val); // 保存节点值 if (node.left) { queue.push(node.left); // 左子节点入队 } if (node.right) { queue.push(node.right); // 右子节点入队 } } return list; } // 深度优先遍历 // 前序遍历 const preOrder = () =\u0026gt; { const list = []; const preOrder1 = (root: TreeNode | null): void =\u0026gt; { if (root === null) { return; } // 访问优先级：根节点 -\u0026gt; 左子树 -\u0026gt; 右子树 list.push(root.val); preOrder1(root.left); preOrder1(root.right); }; return list; }; cookie-session 登录验证 # 用户输入账号密码信息 服务器验证信息正确生成 存储 session 并下发session_id 客户端将 session_id 存储在cookie中 用户每次发起HTTP请求时 将session_id 传回服务器 服务器收到session_id 并跟之前存储的session 验证用户身份 jwt 实现 登录 tooken # jwt(JSON Web Token) 是一种开放标准，用于在各方之间安全传输信息。主要用于身份验证和授权。\nJWT 组成： 头部、负载、签名三部分，之间用.分割。 # 头部：主要描述 JWT 的元数据，包括令牌类型，加密算法等。 负载：数据声明部分，主要包含用户或其他实体信息，如 用户 id，用户名等。有 3 种声明类型：注册声明（JWT 规范中预定义的声明），公共声明（用户自定义的声明），私有声明（使用 JWT 的双方共享的自定义声明） 签名：签名是用于验证消息在传递过程中没有被篡改。它是通过头部中指定的签名算法，对编码后的头部和编码后的负载进行签名计算得到的 JWT 登录鉴权 # 用户输入账号密码信息 服务器验证信息是否正确，返回已签名token（JWT） 将token存储在客户端（local storage）/ cookie 在之后的HTTP请求中将token添加到请求头（一般为Authorazation） 服务器解码JWT，有效则接受请求。 怎么阻止用户直接拿到图片 url # · 服务端控制访问权限 · 服务端加密/混淆 url · 客户端禁止用户右键，禁止用户查看源码 防盗链： 基于 http request refer 设置白名单\n动态规划 # 动态规划 是将一个问题分解为一系列小的子问题，主要用于 寻求最优解。 判断问题是否能以动态规划解决的核心要素为 该问题最终解不依赖历史状态，只依赖于可数的几个子项最优解。 动态规划问题求解步骤一般为： 描述决策，定义状态 找出最优子结构，推导出状态方程。 确定边界条件和状态转移顺序 ","date":"2025-01-19","externalUrl":null,"permalink":"/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%B0%B7%E7%BD%97%E8%8B%B1/","section":"Notes","summary":"","title":"面题 -- 谷罗英","type":"notes"},{"content":" 晓多科技 # 遍历 原型链属性 # for in 可遍历原型链属性，若不需要 可用 for of 或者 添加 hasOwnProperty 判断 获取 不可枚举属性 # Object.getOwnPropertyNames() 方法：返回一个包含对象自身的所有属性（包括不可枚举属性）的数组。 Commonjs(node) 和 es nodule 模块化 导入导出的区别 # CommonJs # 关键字：导入 require 导出 module.exports / exports 可以导出任意类型，为同步加载模块 因此不适用于浏览器（若某个模块加载很慢会导致页面假死）。 CommonJs如何避免循环导入： 首先加载之后的文件的 module 会被缓存到 Module 上，比如一个模块已经 require 引入了 a 模块，如果另外一个模块再次引用 a ，那么会直接读取缓存值 module ，所以无需再次执行模块 module.exports / exports 区别： 如果我们不想在 commonjs 中导出对象，而是只导出一个类或者一个函数再或者其他属性的情况，那么 module.exports 就更方便 exports 会被初始化成一个对象，也就是我们只能在对象上绑定属性 ES Module # 关键字: 导入 import 导出 export / export defult ES6 module 的引入和导出是静态的,可导出任意类型，可默认导出某个属性，导入导出时可用 as 关键字 重命名 导入导出属性。也可用于node 模块化 ES Module 避免循环依赖： ES Module借助模块地图，已经进入过的模块标注为获取中，遇到import语句会去检查这个地图，已经标注为获取中的则不会进入，地图中的每一个节点是一个模块记录，上面有导出变量的内存地址，导入时会做一个连接——即指向同一块内存。 import() 动态引入: import() 返回一个 Promise 对象， 返回的 Promise 的 then 成功回调中，可以获取模块的加载成功信息。 迭代器 / 将对象转换为可迭代对象 # 迭代器是一个对象，它定义一个序列，并在终止时可能附带一个返回值。 迭代器是通过使用 next() 方法实现了迭代器协议的任何一个对象，该方法返回具有两个属性的对象：value 、 done 自定义迭代器： const obj = { arr: [1, 2, 3, 4, 5], [Symbol.iterator]() { let index = 0; //迭代器的结构，下文会提到。此处暂不说明 return { arr: this.arr, next() { if (index \u0026lt; 5) { return { value: this.arr[index++], done: false }; } return { value: undefined, done: true }; }, return() { console.log(\u0026#34;return function\u0026#34;); return { value: \u0026#34;return function\u0026#34;, done: true }; } }; } }; for (let i of obj) { console.log(i); if (i == 2) break; } 生成器 # 生成器是一种特殊的函数。声明函数时，在关键字function后加上一个星号（∗*∗）就可以将这个函数声明为生成器函数。生成器函数调用时，并不会马上执行函数代码块，而是会返回一个生成器对象，生成器对象类似控制器，可以通过next()方法和yield关键字控制生成器函数的进行。 加一个星号还可以加强yield关键字，即yield*。yield*可以对可迭代对象进行迭代，一次调用消费一个值。 怎么理解 响应式 # 用户界面（UI）或数据模型能够自动响应底层数据或状态的变化 useState 为什么不能放在判断语句中 # React 通过单链表来管理 Hooks。update 阶段，每次调用 useState， 链表就会执行 next 向后移动一步。如果将 useState 写在条件判断中，假设条件判断不成立，没有执行里面的 useState 方法，会导致接下来所有的 useState 的取值出现偏移，从而导致异常发生。 深拷贝 # 实现：\nJSON.parse(JSON.stringify(ingredients_list)) structuredClone (通过递归输入对象来构建克隆，同时保持先前访问过的引用的映射，以避免无限遍历循环。) const clone = structuredClone(original) 递归 （缓存引用 以避免循环引用） function deepCopy(obj, map = new Map()) { if (typeof obj != \u0026#34;object\u0026#34;) return; var newObj = Array.isArray(obj) ? [] : {}; if (map.get(obj)) { return map.get(obj); } map.set(obj, newObj); for (var key in obj) { if (obj.hasOwnProperty(key)) { if (typeof obj[key] == \u0026#34;object\u0026#34;) { newObj[key] = deepCopy(obj[key], map); } else { newObj[key] = obj[key]; } } } return newObj; } == 、=== 和 Object.is # == 在比较前 会对数据进行类型转换 转换规则： 1. 如果有一个操作数是布尔值，则在比较相等性之前，将其转换为数值； 2. 如果一个操作数是字符串，另一个操作数是数值，在比较之前先将字符串转换为数值； 3. 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法，用得到的基本类型值按照前面的规则进行比较； 4. 如果有一个操作数是 NaN，无论另一个操作数是什么，相等操作符都返回 false； 5. 如果两个操作数都是对象，则比较它们是不是同一个对象。如果指向同一个对象，则相等操作符返回 true； 6. 在比较相等性之前，不能将 null 和 undefined 转成其他值。 7. null 和 undefined 是相等的。\n=== 不会做类型转换 特例： +0 === -0 // true NaN === NaN // false\nObject.is Object.is(+0, -0); // false Object.is(NaN, NaN); // true\nObject Map 区别 # 1. 构造方法不同 2. 对象的键类型 只会有 字符串 \u0026amp; Symbol，Map 中的键可以是任意类型 3. 对象有原型链 会从原型链继承属性和方法， Map 无 4. 对象中键的顺序 数字或者字符串类型的数字当作key时，输出是按照升序排序的 普通的字符串类型的key，就按照定义的顺序输出 Symbols也是和字符串类型的规则一样 如果是三种类型的key都有，那么顺序是 1 -\u0026gt; 2 -\u0026gt; 3 注：Map键遍历时保留插入顺序 5. 对象与JSON可以相互转化,Map 只会被转化为空对象。 ","date":"2025-01-19","externalUrl":null,"permalink":"/notes/%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%99%93%E5%A4%9A/","section":"Notes","summary":"","title":"面题 -- 晓多科技","type":"notes"},{"content":" ES6 新特性 # 块级作用域 let const 无变量提升 const 创建变量不可更改 箭头函数 解构赋值与扩展运算符 // 解构赋值 const { name, age } = obj; // 扩展运算符 const a = [...arr]; const b = { ...obj }; promise 与 生成器函数 proxy ps:Object.defineProperty 比较 \u0026ndash; df 只能单独定义某个属性，要代理整个对象需要遍历对象，分别代理，数组也是如此；proxy 可以代直接理整个对象。 \u0026ndash; df 在原对象上处理，proxy 则新创建代理对象在代理对象上进行处理 \u0026ndash; proxy 实质创建了一个异质对象，在异质对象中的所有操作\nObject.defineProperty(obj, prop, descriptor); const proxy = new Proxy(target, handler); 新基础数据类型 Symbol、BigInit 新的数据结构 Map、Set new 关键字 # . 创建一个空对象 . 将新对象的proto 赋值为构造函数的 prototype . 将构造函数中的 this 指向该对象 . 执行构造函数，如果构造函数返回引用数据类型 则直接返回该对象，否则返回新对象。\nfunction Person(name: any) { this.name = name; return { name }; } function Person2(name: any) { this.name = name; } Person.prototype = { sayHello() { console.log(\u0026#34;hello\u0026#34;); } }; const person = new Person(\u0026#34;aa\u0026#34;); const person2 = new Person2(\u0026#34;bb\u0026#34;); // Person 返回了引用类型 new 直接将引用类型返回 即 person 是用字面量形式创建的对象,其构造函数为Object console.log(person.__proto__ === Object.prototype); // true // Person2 没有返回值，new 将创建的新对象返回，该对象的__proto__ 指向构造函数Person2的prototype console.log(person2.__proto__ === Person2.prototype); // true console.log(person.constructor === Object); // true js 类型判断 # instanceOf # 语法：obj instanceof Type 功能：判断 obj 是不是 Type 类的实例，只可用来判断引用数据 实现思路： Type 的原型对象是否是 obj 的原型链上的某个对象\nFunction.prototype.myInstanceOf = function (fuc: Function) { let proto = (this as Object).__proto__; const pt = fuc.prototype; while (proto) { if (pt === proto) return true; proto = proto.__proto__; } return false; }; Object.prototype.toString # function typeOf(data) { return Object.prototype.toString.call(data).slice(8, -1); } js brage # native -\u0026gt; h5: 向 webview 注入 js 脚本执行 h5 -\u0026gt; native:\nwebview 劫持请求通信 协议格式： :///?#fragment eg：jsbridge://showToast?text=hello\n通过 webview 提供的接口，app 将 Native 相关方法注入到 JS 的全局对象中。\n深拷贝 处理循环依赖 # WeakMap 缓存引用类型，每次引用类型拷贝时先判断是否存在缓存，有则直接用，无则缓存下来。\nWeakMap 键值必须为引用对象或 Symbol\n转 JSON 进行深拷贝弊端 # \u0026ndash; Date 类型会被转为字符串 \u0026ndash; RegExp、Map 、Set 类型会被转为 空对象， \u0026ndash; 拷贝 function 或遇到循环引用时 会报错 \u0026ndash; 对象属性值为 function、undefind、时 会丢失 \u0026ndash; 对象中有 NaN、Infinity 和-Infinity 的时候，序列化之后会显示 null。\n生成器函数 (手动实现一个 async/await) # // 生成器函数 export function* _async() { const userInfo: number = yield getUserInfo(); console.log(\u0026#34;2222\u0026#34;, userInfo); const name: string = yield () =\u0026gt; { return \u0026#34;dengxi\u0026#34;; }; console.log(\u0026#34;name\u0026#34;, name); const num: number = yield 3; console.log(\u0026#34;num\u0026#34;, num); } export const autoRun = (generator: () =\u0026gt; Generator\u0026lt;any\u0026gt;) =\u0026gt; { const gen = generator(); const next = (data: any) =\u0026gt; { const result = gen.next(data); if (result.done) return; if (result.value instanceof Promise) { result.value.then((res: any) =\u0026gt; { next(res); }); } else if (typeof result.value === \u0026#34;function\u0026#34;) { next(result.value()); } else { next(result.value); } }; next(undefined); }; autoRun(_async); for 循环 forEach 循环 区别 # for 循环： js 自身语法，性能更优，可通过 continue 关键字单次中断，break 关键字 中断整个循环。 forEach 循环：本质是可迭代对象原型方法，执行时会开辟执行栈，因此性能上略逊 for，不可中断，且只能遍历实现了迭代器属性的对象。\n在内部执行 async 方法 有什么区别\nfor 循环内部执行 async 方法时 会等待 await 执行完成后再执行下一次循环。 forEach 循环内部执行 async 方法时 会直接同步执行所有循环后再等待 await 语句执行完成。\nforEach 可以中断么？ 不可自己中断，可通过抛出异常中断\nPromise # 定义: 一个对象有 then 方法且该方法返回一个 promise,有一个状态属性初始为 pending，可转化为 fulfilled 或 rejected 且转化不可逆。（Promise A+ 中定义）\npromise 实例方法： then 、catch、finally promise 原型方法：all、allSettled、race、any、resolve、reject\n\u0026ndash; race：接收一个 promise 数组，返回首个状态变更 的 promise。 \u0026ndash; any：接收一个 promise 数组，返回首个状态变更为 resolve 的 Promise 实例。 \u0026ndash; resolve：接收任意参数，返回一个 fulfilled 状态的 promise 实例，resolve 参数为给定参数 \u0026ndash; reject： 接收任意参数，返回一个带有拒绝原因的 Promise 实例。\nPromise.all # 接收一个 promise 数组，返回一个 promise，当 promise 数组都成功时，该 promise 变更为 fulfield，若有 promise 失败，则该 promise 也失败并返回第一个失败的原因。\nconst p1 = new Promise((res, rej) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;11111111\u0026#34;); res(\u0026#34;promise1 成功返回！\u0026#34;); }, 1000); }); const p2 = new Promise((res, rej) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;22222222\u0026#34;); res(\u0026#34;promise2 成功返回！\u0026#34;); }, 2000); }); const p3 = new Promise((res, rej) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;3333333\u0026#34;); res(\u0026#34;promise3 reject！\u0026#34;); }, 3000); }); const arr = [p1, p2, p3]; const myPromiseAll = (array: Promise\u0026lt;any\u0026gt;[]) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { let count = 0, resList = new Array(array.length); array.forEach((item, index) =\u0026gt; { item.then( (res) =\u0026gt; { resList[index] = res; count++; if (count === array.length) resolve(resList); }, (err) =\u0026gt; reject(err) ); }); }); }; const myPromiseAllByAwait = (array: Promise\u0026lt;any\u0026gt;[]) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { let count = 0, resList = new Array(array.length); try { array.forEach(async (item, index) =\u0026gt; { const res = await item; resList[index] = res; count++; if (count === array.length) resolve(resList); }); } catch (error) { reject(error); } }); }; mapPromiseAll(arr).then( (res) =\u0026gt; { console.log(\u0026#34;res\u0026#34;, res); }, (rej) =\u0026gt; console.log(\u0026#34;rej\u0026#34;, rej) ); Promise.allSettled # 接收一个 promise 数组，返回一个 promise。当数组中所有 promise 状态都变更后，该 promise 才会变更为 resolve，resolve 参数为该 promise 数组\nconst myPromiseAllSettled = (promises: Promise\u0026lt;any\u0026gt;[]) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { let count = 0, resArray = new Array(promises.length); promises.forEach((item, idx) =\u0026gt; { item .then( (res) =\u0026gt; { resArray[idx] = { status: \u0026#34;fulfilled\u0026#34;, value: res }; }, (rej) =\u0026gt; { resArray[idx] = { status: \u0026#34;rejected\u0026#34;, reason: rej }; } ) .finally(() =\u0026gt; { count++; if (count === promises.length) return resolve(resArray); }); }); }); }; Promise.retry # const retry = (callback: () =\u0026gt; Promise\u0026lt;any\u0026gt;, retryTime = 5) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { callback().then( () =\u0026gt; { resolve(retryTime); }, (reason: any) =\u0026gt; { if (!retryTime) reject(reason); else { retry(callback, --retryTime).then(resolve, reject); } } ); }); }; function getProm() { const n = Math.random(); return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; (n \u0026gt; 1 ? resolve(n) : reject(n)), 100); }); } retry(getProm, 4) .then((res) =\u0026gt; console.log(\u0026#34;res\u0026#34;, res)) .catch((err) =\u0026gt; console.log(\u0026#34;err\u0026#34;, err)); async await # async 函数返回的是一个 Promise 对象 await 返回的是当前语句的执行结果\n若当前语句返回一个 promise，则 await 会阻塞后续代码执行 等待当前 promise 状态变更为 resolve，然后得到 resolve 的值作为 await 表达式的运算结果 当前语句返回的不是一个 promise，await 表达式直接将该值作为运算结果。 怎么做到同步执行的 # 只是相对于 当前 async 函数内 后续语句同步 将后续语句包装成异步回调\ncanvas / 图片 相互转化 # 图片转 canvas： 将图片绘制在 canvas 上( drawImage() ),该方法接受三个参数：要绘制的图像、起始点的 x 坐标和 y 坐标。 eg:\nvar canvas = document.getElementById(\u0026#34;myCanvas\u0026#34;); var ctx = canvas.getContext(\u0026#34;2d\u0026#34;); var img = new Image(); img.onload = function () { ctx.drawImage(img, 0, 0); }; img.src = \u0026#34;image.jpg\u0026#34;; canvas 转图片：调用 toDataURL()方法将 Canvas 转换为图片的数据 URL。可以将数据 URL 赋值给一个标签的 src 属性，或者使用它进行其他操作，如下载图片。 eg:\nvar canvas = document.getElementById(\u0026#34;myCanvas\u0026#34;); var dataURL = canvas.toDataURL(\u0026#34;image/png\u0026#34;); apply call bind # fn.apply(thisObj, [1, 2, 3]); fn.call(thisObj, 1, 2, 3); const a = fn.bind(thisObj, 1, 2, 3); a(); ","date":"2025-01-19","externalUrl":null,"permalink":"/notes/js/","section":"Notes","summary":"记录 整理遇到的八股文知识点之 js篇","title":"八股文 -- JS","type":"notes"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/series/react18-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","section":"Series","summary":"","title":"React18 阅读笔记","type":"series"},{"content":" 配置好的仓库自取(带阅读笔记版): react-debug github link vite # 创建项目 # pnpm create vite # (根据提示配置项目) ... 下载 react 源码 # github 地址：https://github.com/facebook/react 切换 tag ，找到对应版本 本文是 18.2.0 版本\n# 切换目录到src下，直接clone整个react资源包 cd src git clone git@github.com:facebook/react.git 配置 vite.config.js # import { defineConfig } from \u0026#34;vite\u0026#34;; import react from \u0026#34;@vitejs/plugin-react\u0026#34;; import path from \u0026#34;path\u0026#34;; // https://vitejs.dev/config/ export default defineConfig({ plugins: [react()], resolve: { // 配置别名 alias: { react: path.posix.resolve(\u0026#34;src/react/packages/react\u0026#34;), \u0026#34;react-dom\u0026#34;: path.posix.resolve(\u0026#34;src/react/packages/react-dom\u0026#34;), \u0026#34;react-dom-bindings\u0026#34;: path.posix.resolve( \u0026#34;src/react/packages/react-dom-bindings\u0026#34; ), \u0026#34;react-reconciler\u0026#34;: path.posix.resolve( \u0026#34;src/react/packages/react-reconciler\u0026#34; ), \u0026#34;react-client\u0026#34;: path.posix.resolve(\u0026#34;src/react/packages/react-client\u0026#34;), scheduler: path.posix.resolve(\u0026#34;src/react/packages/scheduler\u0026#34;), shared: path.posix.resolve(\u0026#34;src/react/packages/shared\u0026#34;) } }, // 配置环境变量 define: { __DEV__: false, __EXPERIMENTAL__: true, __PROFILE__: true } }); 由于 DEV 配置的 false，需要手动改赋值一下 jsxDEV\n// path: src/react/packages/react/src/jsx/ReactJSX.js // 注释掉原来的 赋值 直接赋值为 _jsxDEV(之前赋值为 jsxProd 会报错 没解决掉) // const jsxDEV = __DEV__ ? _jsxDEV : undefined; const jsxDEV = _jsxDEV; 配置 tsconfig.json / jsconfig.json # // ... \u0026#34;compilerOptions\u0026#34;: { \u0026#34;baseUrl\u0026#34;: \u0026#34;./\u0026#34;, \u0026#34;paths\u0026#34;: { \u0026#34;react/*\u0026#34;: [ \u0026#34;src/react/packages/react/*\u0026#34; ], \u0026#34;react-dom/*\u0026#34;: [ \u0026#34;src/react/packages/react-dom/*\u0026#34; ], \u0026#34;react-dom-bindings/*\u0026#34;: [ \u0026#34;src/react/packages/react-dom-bindings/*\u0026#34; ], \u0026#34;react-reconciler/*\u0026#34;: [ \u0026#34;src/react/packages/react-reconciler/*\u0026#34; ], \u0026#34;scheduler/*\u0026#34;: [ \u0026#34;src/react/packages/scheduler/*\u0026#34; ], \u0026#34;shared/*\u0026#34;: [ \u0026#34;src/react/packages/shared/*\u0026#34; ] } }, // ... vscode 调试 # 初始化launch.js # 回退到项目根目录 cd .. # 安装依赖 pnpm i # 起项目 pnpm dev F5 启动调试\n解决报错 # 参考:\nReact 18 debugger 源码分析配置\nwebpack # 创建项目 # npx create-react-app debug-react # 暴露webpack 配置 npm run eject 下载 react 源码 # github 地址：https://github.com/facebook/react 切换 tag ，找到对应版本 本文是 18.2.0 版本\n# 切换目录到src下，直接clone整个react资源包 cd src git clone git@github.com:facebook/react.git 修改配置 # // config/webpack.config.js \u0026#39;react\u0026#39;: path.resolve(__dirname, \u0026#39;../src/react/packages/react\u0026#39;), \u0026#39;react-dom\u0026#39;: path.resolve(__dirname, \u0026#39;../src/reactpackages/react-dom\u0026#39;), \u0026#39;react-dom-bindings\u0026#39;: path.resolve(__dirname, \u0026#39;../srcreact/packages/react-dom-bindings\u0026#39;), \u0026#39;react-reconciler\u0026#39;: path.resolve(__dirname, \u0026#39;../srcreact/packages/react-reconciler\u0026#39;), \u0026#39;shared\u0026#39;: path.resolve(__dirname, \u0026#39;../src/react/packagesshared\u0026#39;), \u0026#39;scheduler\u0026#39;: path.resolve(__dirname, \u0026#39;../src/reactpackages/scheduler\u0026#39;), webpack 配置 alias // /config/env.js __DEV__: true, __PROFILE__: true, __UMD__: true, __EXPERIMENTAL__: true, __VARIANT__: true, 全局变量 解决报错 # 参考\n手把手教你配置 React18 调试环境\n","date":"2025-01-19","externalUrl":null,"permalink":"/react/debug/","section":"Reacts","summary":"简述如何利用打包工具 webpack / vite 配置 react debug 环境","title":"React18 阅读笔记 -- debug 环境搭建","type":"react"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/react/","section":"Reacts","summary":"","title":"Reacts","type":"react"},{"content":"","date":"2025-01-18","externalUrl":null,"permalink":"/tags/react/","section":"Tags","summary":"","title":"React","type":"tags"},{"content":" 入口 # function beginWork( current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes ): Fiber | null { // ...省略，这里只关注 switch case 部分 // 这里列举全部 case，下面会对部分case进行梳理 switch (workInProgress.tag) { // 挂载时, 此时的 function class 组件还未区分，都走该case case IndeterminateComponent: { return mountIndeterminateComponent( current, workInProgress, workInProgress.type, renderLanes ); } case LazyComponent: { const elementType = workInProgress.elementType; return mountLazyComponent( current, workInProgress, elementType, renderLanes ); } case FunctionComponent: { const Component = workInProgress.type; const unresolvedProps = workInProgress.pendingProps; const resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps); return updateFunctionComponent( current, workInProgress, Component, resolvedProps, renderLanes ); } case ClassComponent: { const Component = workInProgress.type; const unresolvedProps = workInProgress.pendingProps; const resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps); return updateClassComponent( current, workInProgress, Component, resolvedProps, renderLanes ); } // 在 create 中 已梳理 case HostRoot: return updateHostRoot(current, workInProgress, renderLanes); case HostComponent: return updateHostComponent(current, workInProgress, renderLanes); case SuspenseComponent: return updateSuspenseComponent(current, workInProgress, renderLanes); case HostPortal: return updatePortalComponent(current, workInProgress, renderLanes); case ForwardRef: { const type = workInProgress.type; const unresolvedProps = workInProgress.pendingProps; const resolvedProps = workInProgress.elementType === type ? unresolvedProps : resolveDefaultProps(type, unresolvedProps); return updateForwardRef( current, workInProgress, type, resolvedProps, renderLanes ); } case Mode: return updateMode(current, workInProgress, renderLanes); case Profiler: return updateProfiler(current, workInProgress, renderLanes); case ContextProvider: return updateContextProvider(current, workInProgress, renderLanes); case ContextConsumer: return updateContextConsumer(current, workInProgress, renderLanes); case MemoComponent: { const type = workInProgress.type; const unresolvedProps = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props. let resolvedProps = resolveDefaultProps(type, unresolvedProps); resolvedProps = resolveDefaultProps(type.type, resolvedProps); return updateMemoComponent( current, workInProgress, type, resolvedProps, renderLanes ); } // ...省略部分 case } } case 梳理 # 在梳理具体 case 之前，将简单介绍部分 公共方法\nexport function prepareToReadContext( workInProgress: Fiber, renderLanes: Lanes ): void { currentlyRenderingFiber = workInProgress; lastContextDependency = null; lastFullyObservedContext = null; const dependencies = workInProgress.dependencies; if (dependencies !== null) { const firstContext = dependencies.firstContext; if (firstContext !== null) { if (includesSomeLane(dependencies.lanes, renderLanes)) { //将 ReactFiberBeginWork 中的 局部属性 didReceiveUpdate 值更改为 true; markWorkInProgressReceivedUpdate(); } dependencies.firstContext = null; } } } IndeterminateComponent # 函数组件 \u0026amp; 类组件 首次挂载时都会走到该 case 会先执行 renderWithHooks 方法 后 判断 value 是否有 render 方法 来确认是 函数组件 or 类组件 并给 fiber 打标。函数组件 类组件 具体实现 在对应 case 中梳理\nfunction mountIndeterminateComponent( _current, workInProgress, Component, renderLanes ) { const props = workInProgress.pendingProps; let context; prepareToReadContext(workInProgress, renderLanes); value = renderWithHooks( null, workInProgress, Component, props, context, renderLanes ); if ( typeof value === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; value !== null \u0026amp;\u0026amp; typeof value.render === \u0026#34;function\u0026#34; \u0026amp;\u0026amp; value.$$typeof === undefined ) { workInProgress.tag = ClassComponent; // TODO 类组件挂载时 具体实现流程梳理 } else { workInProgress.tag = FunctionComponent; // 将子节点 reconcileChildren(null, workInProgress, value, renderLanes); return workInProgress.child; } } FunctionComponent # function updateFunctionComponent( current, workInProgress, Component, nextProps: any, renderLanes ) { // ... let context, nextChildren, hasId; prepareToReadContext(workInProgress, renderLanes); nextChildren = renderWithHooks( current, workInProgress, Component, nextProps, context, renderLanes ); // ...省略部分代码 只关注 主要步骤 // React DevTools reads this flag. workInProgress.flags |= PerformedWork; reconcileChildren(current, workInProgress, nextChildren, renderLanes); return workInProgress.child; } renderWithHooks # export function renderWithHooks\u0026lt;Props, SecondArg\u0026gt;( current: Fiber | null, workInProgress: Fiber, Component: (p: Props, arg: SecondArg) =\u0026gt; any, props: Props, secondArg: SecondArg, nextRenderLanes: Lanes ): any { // 将 HooksDispatcher 切换为 update ReactCurrentDispatcher.current = current === null || current.memoizedState === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate; // 这里的 Component 则为具体的 函数组件 let children = Component(props, secondArg); return children; } LazyComponent # function mountLazyComponent( _current, workInProgress, elementType, renderLanes ) { const props = workInProgress.pendingProps; const lazyComponent: LazyComponentType\u0026lt;any, any\u0026gt; = elementType; const payload = lazyComponent._payload; const init = lazyComponent._init; let Component = init(payload); workInProgress.type = Component; const resolvedTag = (workInProgress.tag = resolveLazyComponentTag(Component)); const resolvedProps = resolveDefaultProps(Component, props); let child; switch (resolvedTag) { case FunctionComponent: { // 具体流程在对应case中梳理 } case ClassComponent: { // ... } // ... } } // 该方法会在 renderWidthHook 中执行,后在 遍历到 lazy 组件时 执行 init 初始化组件 // 后续更新 则走 对应分支 export function lazy\u0026lt;T\u0026gt;( ctor: () =\u0026gt; Thenable\u0026lt;{default: T, ...}\u0026gt;, ): LazyComponent\u0026lt;T, Payload\u0026lt;T\u0026gt;\u0026gt; { const payload: Payload\u0026lt;T\u0026gt; = { // We use these fields to store the result. _status: Uninitialized, _result: ctor, }; const lazyType: LazyComponent\u0026lt;T, Payload\u0026lt;T\u0026gt;\u0026gt; = { $$typeof: REACT_LAZY_TYPE, _payload: payload, _init: lazyInitializer, }; return lazyType; } function lazyInitializer\u0026lt;T\u0026gt;(payload: Payload\u0026lt;T\u0026gt;): T { if (payload._status === Uninitialized) { const ctor = payload._result; // 执行异步加载方法 （一般是 import()） const thenable = ctor(); thenable.then( moduleObject =\u0026gt; { // 同步 lazy 组件 的状态与加载结果 if (payload._status === Pending || payload._status === Uninitialized) { // Transition to the next state. payload._status = Resolved; payload._result = moduleObject; } }, error =\u0026gt; { if (payload._status === Pending || payload._status === Uninitialized) { // Transition to the next state. payload._status = Rejected; payload._result = error; } }, ); if (payload._status === Uninitialized) { // 首次进来时改为 Pending 状态 const pending: PendingPayload = (payload: any); pending._status = Pending; pending._result = thenable; } } if (payload._status === Resolved) { // 如果 promise 完成了，那么会将加载的模块返回 const moduleObject = payload._result; return moduleObject.default; } else { // 第一次加载时，报错 throw payload._result; } } HostComponent # const isDirectTextChild = shouldSetTextContent(type, nextProps); // \u0026hellip; reconcileChildren(current, workInProgress, nextChildren, renderLanes);\nSuspenseComponent # TODO 后续补充\nHostPortal # function updatePortalComponent( current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes ) { // 在它的子节点被添加时，可以找到这个containerInfo节点。 // 这样就可以达到fiber在rootFiber内，但是添加的真实节点在其他节点的目的 pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo); const nextChildren = workInProgress.pendingProps; reconcileChildren(current, workInProgress, nextChildren, renderLanes); return workInProgress.child; } export function createPortal( children: ReactNodeList, containerInfo: any, implementation: any, key: ?string = null ): ReactPortal { return { $$typeof: REACT_PORTAL_TYPE, key: key == null ? null : \u0026#34;\u0026#34; + key, children, containerInfo, implementation }; } export function createFiberFromPortal( portal: ReactPortal, mode: TypeOfMode, lanes: Lanes ): Fiber { const pendingProps = portal.children !== null ? portal.children : []; const fiber = createFiber(HostPortal, pendingProps, portal.key, mode); fiber.lanes = lanes; fiber.stateNode = { containerInfo: portal.containerInfo, pendingChildren: null, // Used by persistent updates implementation: portal.implementation }; return fiber; } # ","date":"2025-01-18","externalUrl":null,"permalink":"/react/beginwork_case/","section":"Reacts","summary":"聚焦 beginwork 中针对 不同的 tag 具体实现逻辑","title":"React18 阅读笔记 -- BeginWork case 梳理","type":"react"},{"content":" completeWork # 根据 workInProgress.tag 找到需要创建/更新 dom 的 tag，根据 fiber 创建/更新 dom\n// path: packages/react-reconciler/src/ReactFiberCompleteWork.old.js function completeWork( current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes ): Fiber | null { switch (workInProgress.tag) { case IndeterminateComponent: case LazyComponent: case SimpleMemoComponent: case FunctionComponent: case ForwardRef: case Fragment: case Mode: case Profiler: case ContextConsumer: case MemoComponent: bubbleProperties(workInProgress); return null; case HostText: { // ...省略部分代码 // 根据不同tag 为 stateNode 创建 对应dom 节点 workInProgress.stateNode = createTextInstance( newText, rootContainerInstance, // root currentHostContext, workInProgress ); // 将所有child 的 return赋值为 completedWork； // 计算 completedWork 的 subtreeFlags bubbleProperties(workInProgress); return null; } case HostComponent: { // 将当前 fiber 移出 fiberStack popHostContext(workInProgress); // 在beginWork中对于HostRoot和HostPortal节点都会将真实节点container全 // 局存储到rootInstanceStackCursor.current，而在completeWork阶段将其移出。 // 在访问子节点时就能正确获取到它所在的容器 // 获取的是当前的 RootHostContainer const rootContainerInstance = getRootHostContainer(); const type = workInProgress.type; if (current !== null \u0026amp;\u0026amp; workInProgress.stateNode != null) { // // 如果真实节点存在，那么进行更新 updateHostComponent( current, workInProgress, type, newProps, rootContainerInstance ); } else { if (!newProps) { bubbleProperties(workInProgress); return null; } const currentHostContext = getHostContext(); const instance = createInstance( type, newProps, rootContainerInstance, currentHostContext, workInProgress ); // 将能渲染的子节点全部添加到当前创建的节点instance上 appendAllChildren(instance, workInProgress, false, false); workInProgress.stateNode = instance; } bubbleProperties(workInProgress); return null; } } } HostComponent # root 根节点 进如的 case\nexport function updateHostComponent() { // ... // 类似结构：[\u0026#39;name\u0026#39;, \u0026#39;张三\u0026#39;, \u0026#39;id\u0026#39;, 333, \u0026#39;style\u0026#39;, { color: \u0026#39;red\u0026#39; }] const updatePayload = prepareUpdate( instance, type, oldProps, newProps, rootContainerInstance, currentHostContext, ); workInProgress.updateQueue = (updatePayload: any); // 标记为 Update if (updatePayload) { markUpdate(workInProgress); } }; export function createInstance( type: string, props: Props, rootContainerInstance: Container, hostContext: HostContext, internalInstanceHandle: Object ): Instance { // 创建了 element const domElement: Instance = createElement( type, props, rootContainerInstance, parentNamespace ); // 建立关系 node . \u0026#39;__reactFiber$\u0026#39; + randomKey = fiber precacheFiberNode(internalInstanceHandle, domElement); // 建立关系 node . \u0026#39;__reactProps$\u0026#39; + randomKey = props updateFiberProps(domElement, props); return domElement; } ","date":"2025-01-18","externalUrl":null,"permalink":"/react/completework/","section":"Reacts","summary":"workloop 的 归 阶段， 根据已经创建/更新 好的 fiber 开始构建真实dom，TODO:有时间需要再梳理一下","title":"React18 阅读笔记 -- completeWork","type":"react"},{"content":" 入口 # // path: packages/react-reconciler/src/ReactFiberBeginWork.old.js beginWork = (current, unitOfWork, lanes) =\u0026gt; { didReceiveUpdate = false; workInProgress.lanes = NoLanes; // 一大堆switch case 单独放在下一个文件中整理 // 这里只处理了 unitOfWork 为 hostRoot 的case return updateHostRoot(current, workInProgress, renderLanes); }; function updateHostRoot(current, workInProgress, renderLanes) { pushHostRootContext(workInProgress); // 将 current 的 UpdateQueue 拷贝给 workInProgress cloneUpdateQueue(current, workInProgress); /** * 将当前将要进行的更新 shared.pending 的环形链表，拆开拼接到到 lastBaseUpdate 的后面； * 执行 firstBaseUpdate 链表的操作时，若当前 update 对应的任务的优先级符合要求，则执行； * 若优先级较低，则存储执行到当前节点的状态，做为下次渲染时的初始值，和接下来所有的 update 节点； * 将执行所有操作后得到的 newState 重新给到 workInProgress.memoizedState； * 然后存储刚才淘汰下来的低优先级任务的链表，以便下次更新； */ processUpdateQueue(workInProgress, nextProps, null, renderLanes); const nextState: RootState = workInProgress.memoizedState; const root: FiberRoot = workInProgress.stateNode; const nextChildren = nextState.element; reconcileChildren(current, workInProgress, nextChildren, renderLanes); return workInProgress.child; } reconcileChildren # // export const reconcileChildFibers = ChildReconciler(true); // export const mountChildFibers = ChildReconciler(false); // 该初始化参数b表示是否有 current ,未在 reconcileChildFibers 中使用 function reconcileChildren( current: Fiber | null, workInProgress: Fiber, nextChildren: any, renderLanes: Lanes ) { if (current === null) { // mountChildFibers 也就是初始化 ChildReconciler 后 执行 reconcileChildFibers workInProgress.child = mountChildFibers( workInProgress, null, nextChildren, renderLanes ); // 更新阶段 } else { workInProgress.child = reconcileChildFibers( workInProgress, current.child, nextChildren, renderLanes ); } } reconcileChildFibers # // path: packages/react-reconciler/src/ReactChildFiber.old.js // 根据 newChild.$$typeof 不同类型 创建 fiber function reconcileChildFibers( returnFiber: Fiber, currentFirstChild: Fiber | null, newChild: any, lanes: Lanes ): Fiber | null { if (typeof newChild === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; newChild !== null) { switch (newChild.$$typeof) { case REACT_ELEMENT_TYPE: // react.element return placeSingleChild( // 调用 createFiberFromElement 为child 创建 fiber reconcileSingleElement( returnFiber, currentFirstChild, newChild, lanes ) ); case REACT_LAZY_TYPE: // react.lazy const payload = newChild._payload; const init = newChild._init; // TODO: This function is supposed to be non-recursive. return reconcileChildFibers( returnFiber, currentFirstChild, // _init: lazyInitializer, 具体实现 放在 update 中梳理 init(payload), lanes ); case REACT_PORTAL_TYPE: // react.portal return placeSingleChild( reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes) ); } // child有多个 if (isArray(newChild)) { return reconcileChildrenArray( returnFiber, currentFirstChild, newChild, lanes ); } throwOnInvalidObjectType(returnFiber, newChild); } } REACT_ELEMENT_TYPE # 当类型为 react.element 时，会先调用 reconcileSingleElement 方法，校验 key 和 type 是否一致，如果一致则使用 useFiber 方法进行复用 fiber。然后 调用 placeSingleChild 根据 current 与 当前 finber.alternate 判断是否需要给 fiber.flages 标记为新增\nfunction reconcileSingleElement( returnFiber: Fiber, currentFirstChild: Fiber | null, element: ReactElement, lanes: Lanes ): Fiber { const key = element.key; let child = currentFirstChild; while (child !== null) { // key 一致 直接复用 if (child.key === key) { const elementType = element.type; if (elementType === REACT_FRAGMENT_TYPE) { if (child.tag === Fragment) { // 如果是 Fragment 标签 则跳过直接复用 Fragment 的 children deleteRemainingChildren(returnFiber, child.sibling); const existing = useFiber(child, element.props.children); existing.return = returnFiber; return existing; } } else { deleteRemainingChildren(returnFiber, child.sibling); const existing = useFiber(child, element.props); existing.ref = coerceRef(returnFiber, child, element); existing.return = returnFiber; return existing; } // Didn\u0026#39;t match. // 遍历所有子节点 将 child 加入 fiber.deletions 并将 renturnFiber.flags 标记为 ChildDeletion deleteRemainingChildren(returnFiber, child); break; } else { deleteChild(returnFiber, child); } child = child.sibling; } // 否则直接新建fiber if (element.type === REACT_FRAGMENT_TYPE) { const created = createFiberFromFragment( element.props.children, returnFiber.mode, lanes, element.key ); created.return = returnFiber; return created; } else { const created = createFiberFromElement(element, returnFiber.mode, lanes); created.ref = coerceRef(returnFiber, currentFirstChild, element); created.return = returnFiber; return created; } } function placeSingleChild(newFiber: Fiber): Fiber { if (shouldTrackSideEffects \u0026amp;\u0026amp; newFiber.alternate === null) { newFiber.flags |= Placement; } return newFiber; } REACT_LAZY_TYPE # reconcileChildrenArray # function reconcileChildrenArray( returnFiber: Fiber, currentFirstChild: Fiber | null, newChildren: Array\u0026lt;*\u0026gt;, lanes: Lanes ): Fiber | null { let resultingFirstChild: Fiber | null = null; let previousNewFiber: Fiber | null = null; // oldFiber 是老 fiber 的第一个 child，可以通过 sibling 进行遍历。 let oldFiber = currentFirstChild; // lastPlacedIndex 表示最后一个老fiber被复用的位置 let lastPlacedIndex = 0; // 表示新 ReactElement 的位置 let newIdx = 0; // 表示下一个老fiber let nextOldFiber = null; // Diff 算法，标记子节点中需要的操作，记录在 flags 中 // 这个位置相当于只对比了前面的一部分， // 如果出现 key 和 type 不一致的情况，那么会跳出对比。 for (; oldFiber !== null \u0026amp;\u0026amp; newIdx \u0026lt; newChildren.length; newIdx++) { if (oldFiber.index \u0026gt; newIdx) { // 一直找到 oldFiber index 与 newIdx 相等的节点 // 否则的话，oldFiber 不向后遍历。 nextOldFiber = oldFiber; oldFiber = null; } else { // 遍历下一个 fiber nextOldFiber = oldFiber.sibling; } // 这里的 newChildren 是 jsx 解析出来的 children，为 ReactElement节点 // 根据节点类型创建或者更新 fiber const newFiber = updateSlot( returnFiber, oldFiber, newChildren[newIdx], lanes ); if (newFiber === null) { // key 或 type 不相同时，不可复用。 // 此时 newFiber 为 null，对比就会终止。 // 这就意味着找到了第一个无法复用的节点 if (oldFiber === null) { oldFiber = nextOldFiber; } break; } // 更新时 需要标记 if (shouldTrackSideEffects) { if (oldFiber \u0026amp;\u0026amp; newFiber.alternate === null) { // 将老的fiber 添加 ChildDeletion 标记 deleteChild(returnFiber, oldFiber); } } // 取 current.index 和 lastPlacedIndex 最大值 // 并给 newFiber.flag 添加 Placement / Forked 标记 lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx); // 建立 newFiber 之间的联系 if (previousNewFiber === null) { resultingFirstChild = newFiber; } else { previousNewFiber.sibling = newFiber; } previousNewFiber = newFiber; oldFiber = nextOldFiber; } // 遍历跳出之后，会判断老fiber或者是新ReactElement遍历完成没。 // 如果 newChildren 遍历完成，那么所有剩余的老fiber都应该标记为删除 if (newIdx === newChildren.length) { // 标记删除，记录到 父 fiber 的 deletions 属性中 deleteRemainingChildren(returnFiber, oldFiber); return resultingFirstChild; } // 如果老fiber遍历完成，那么所有剩余新的ReactElement都是新插入的节点，创建newFiber if (oldFiber === null) { for (; newIdx \u0026lt; newChildren.length; newIdx++) { // 根据 ReactElement 创建 fiber const newFiber = createChild(returnFiber, newChildren[newIdx], lanes); if (newFiber === null) { continue; } // 为 newFiber.flage 添加 place 标记 lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx); if (previousNewFiber === null) { // TODO: Move out of the loop. This only happens for the first run. resultingFirstChild = newFiber; } else { previousNewFiber.sibling = newFiber; } previousNewFiber = newFiber; } return resultingFirstChild; } // 后续的是因为 key 和 type 不一致导致没有遍历完的数组。 // 此时开始复用的算法。 // 首先将老节点转换为 map 形式：{ key|index : fiber } const existingChildren = mapRemainingChildren(returnFiber, oldFiber); for (; newIdx \u0026lt; newChildren.length; newIdx++) { // 从 existingChildren 中匹配 newIdx / newChild.key， // 若匹配到 则调用 useFiber 复用拿出存储的 oldFiber // 否则创建 新fiber const newFiber = updateFromMap( existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes ); if (newFiber !== null) { if (shouldTrackSideEffects) { if (newFiber.alternate !== null) { // 如果已经复用了，在 map 中删除对应的 fiber existingChildren.delete( newFiber.key === null ? newIdx : newFiber.key ); } } // 能复用时，更新最后一个复用的 老fiber 的 index lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx); if (previousNewFiber === null) { resultingFirstChild = newFiber; } else { previousNewFiber.sibling = newFiber; } previousNewFiber = newFiber; } } if (shouldTrackSideEffects) { // 将所有没有被复用的老fiber标记为删除 existingChildren.forEach((child) =\u0026gt; deleteChild(returnFiber, child)); } return resultingFirstChild; } // 用于 diff 算法，标记最后匹配的 old fiber 的位置 function placeChild( newFiber: Fiber, lastPlacedIndex: number, newIndex: number ): number { newFiber.index = newIndex; // 当父亲的 current 不存在时，此时为 mount，shouldTrackSideEffects 为 false，不用做处理。 // 当父亲的 current 存在时，shouldTrackSideEffects 为 true。 // 例如，当遇到第一个需要重新创建的节点时，它对应的 parent 的 current 存在，标记为更新。 // 当遍历到子节点时，由于子节点对应的 parent 的 current 不存在，此时不标记更新。 // 这样做的好处是，只有父亲被标记为更新，而其后代均不作标记。 // 在 completeWork 的时候子节点直接全添加到父亲上。 // 在 commit 的时候只需要将父亲添加到 根节点上即可。 if (!shouldTrackSideEffects) { return lastPlacedIndex; } // 如果复用了 老fiber const current = newFiber.alternate; if (current !== null) { const oldIndex = current.index; // 如果老的 index \u0026lt; lastPlacedIndex，说明这些老的节点无法复用。 if (oldIndex \u0026lt; lastPlacedIndex) { // 不可复用，需要替换 newFiber.flags |= Placement; return lastPlacedIndex; } else { // This item can stay in place. // 否则说明这个老节点可以复用，返回老节点 index return oldIndex; } } else { // 如果 老 fiber不存在，那么需要替换 // 注意这里被标记了，commit的时候会进行处理 newFiber.flags |= Placement; return lastPlacedIndex; } } ","date":"2025-01-17","externalUrl":null,"permalink":"/react/beginwork_fiber/","section":"Reacts","summary":"聚焦 react fiber 调度的单元 beginWork 大致梳理其如何创建/更新/diff fiber 的","title":"React18 阅读笔记 -- beginwork fiber","type":"react"},{"content":" commitRoot # beginWork 和 completeWork 阶段都正常结束后，此时所有的 fiber 和真实节点创建完成，进入到 commit 阶段：\nfinishConcurrentRender(root, exitStatus, lanes) { switch (exitStatus) { case RootCompleted: { // The work completed. Ready to commit. commitRoot( root, workInProgressRootRecoverableErrors, workInProgressTransitions, ) break; } } } function commitRoot(root) { const previousUpdateLanePriority = getCurrentUpdatePriority(); const prevTransition = ReactCurrentBatchConfig.transition; try { ReactCurrentBatchConfig.transition = 0; // 优先级为同步，不可被打断 setCurrentUpdatePriority(DiscreteEventPriority); commitRootImpl(root, previousUpdateLanePriority); } finally { ReactCurrentBatchConfig.transition = prevTransition; setCurrentUpdatePriority(previousUpdateLanePriority); } return null; } commitRootImpl # 具体执行方法，先检测是否有上轮更新未执行的 effect，如果有则先调用 flushPassiveEffects 同步执行上轮遗留 effect 任务。 否则通过 scheduleCallback 将 本轮 effect 加入到 任务队列(taskQueue)中。\nfunction commitRootImpl( root: FiberRoot, recoverableErrors: null | Array\u0026lt;CapturedValue\u0026lt;mixed\u0026gt;\u0026gt;, transitions: Array\u0026lt;Transition\u0026gt; | null, renderPriorityLevel: EventPriority ) { do { flushPassiveEffects(); } while (rootWithPendingPassiveEffects !== null); const finishedWork = root.finishedWork; const lanes = root.finishedLanes; root.finishedWork = null; root.finishedLanes = NoLanes; root.callbackNode = null; root.callbackPriority = NoLane; // 如果flags/subtreeFlags中存在PassiveMask，即Passive|ChildDeletion， // 那么 rootDoesHavePassiveEffects 为true。也就是说如果使用了useEffect或者是节点有删除的情况 // 那么就会执行flushPassiveEffects方法： if ( (finishedWork.subtreeFlags \u0026amp; PassiveMask) !== NoFlags || (finishedWork.flags \u0026amp; PassiveMask) !== NoFlags ) { if (!rootDoesHavePassiveEffects) { rootDoesHavePassiveEffects = true; // 异步执行 useEffect scheduleCallback(NormalSchedulerPriority, () =\u0026gt; { flushPassiveEffects(); return null; }); } } // 如果subtreeHasEffects或rootHasEffect存在，说明有更新。 // 首先会进入beforeMutation阶段，调用commitBeforeMutationEffects方法： if (subtreeHasEffects || rootHasEffect) { const shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects( root, finishedWork ); } commitMutationEffects(root, finishedWork, lanes); // 同步执行 useLayoutEffect 的 create 并存储 destroy commitLayoutEffects(finishedWork, root, lanes); if (rootDoesHavePassiveEffects) { rootDoesHavePassiveEffects = false; rootWithPendingPassiveEffects = root; pendingPassiveEffectsLanes = lanes; } root.current = finishedWork; // 如果还有未完成的更新，即优先级不够的更新，那么这里会被继续调度进行更新。 ensureRootIsScheduled(root, now()); // 如果当前更新中包含useEffect，并且lanes中含有同步lane，那么需要立即执行flushPassiveEffect // 相比于schedule执行flushPassiveEffects，这里执行更靠前。 if ( includesSomeLane(pendingPassiveEffectsLanes, SyncLane) \u0026amp;\u0026amp; root.tag !== LegacyRoot ) { flushPassiveEffects(); } flushSyncCallbacks(); return null; } // flushPassiveEffects export function flushPassiveEffects(): boolean { // 如果 rootWithPendingPassiveEffects 存在，说明使用了 useEffect 或者有子节点被删除 if (rootWithPendingPassiveEffects !== null) { const renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes); const priority = lowerEventPriority(DefaultEventPriority, renderPriority); const prevTransition = ReactCurrentBatchConfig.transition; const previousPriority = getCurrentUpdatePriority(); try { // transition 置为 0 ReactCurrentBatchConfig.transition = 0; // 设置 update 优先级，获取 lane 的时候会用得到 setCurrentUpdatePriority(priority); return flushPassiveEffectsImpl(); } finally { setCurrentUpdatePriority(previousPriority); ReactCurrentBatchConfig.transition = prevTransition; } } return false; } function flushPassiveEffectsImpl() { if (rootWithPendingPassiveEffects === null) { return false; } // 针对 fiber.flags === ChildDeletion 的 节点 执行 // commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor); // 对 function 组件 通过调用 // safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy); // 方法 执行 destroy。然后在 // commitPassiveUnmountEffectsInsideOfDeletedTree_complete // 方法中删除fiber引用并且删除对应真实节点的引用 // 到底后 执行 commitPassiveUnmountInsideDeletedTreeOnFiber 自下而上处理兄弟节点 commitPassiveUnmountEffects(root.current); // 同上步骤 调用effects里的 create 方法并生成destroy commitPassiveMountEffects(root, root.current, lanes, transitions); flushSyncCallbacks(); } BeforeMutationEffects # // BeforeMutationEffects 阶段 export function commitBeforeMutationEffects( root: FiberRoot, firstChild: Fiber ) { focusedInstanceHandle = prepareForCommit(root.containerInfo); nextEffect = firstChild; commitBeforeMutationEffects_begin(); // 。。。省略部分代码 } function commitBeforeMutationEffects_begin() { // 向下遍历，直到找到一个不符合BeforeMutationMask的节点 while (nextEffect !== null) { const fiber = nextEffect; const child = fiber.child; // export const BeforeMutationMask = Update | Snapshot if ( (fiber.subtreeFlags \u0026amp; BeforeMutationMask) !== NoFlags \u0026amp;\u0026amp; child !== null ) { child.return = fiber; nextEffect = child; } else { commitBeforeMutationEffects_complete(); } } } // 自下往上遍历，执行 commitBeforeMutationEffectsOnFiber function commitBeforeMutationEffects_complete() { while (nextEffect !== null) { const fiber = nextEffect; // 处理 class组件中定义的getSnapshotBeforeUpdate函数 // 或者 处理 current === null || current.child === null 的HostRoot // 将 root.containerInfo 真实节点的内容置空 commitBeforeMutationEffectsOnFiber(fiber); const sibling = fiber.sibling; if (sibling !== null) { sibling.return = fiber.return; nextEffect = sibling; return; } nextEffect = fiber.return; } } mutation # export function commitMutationEffects( root: FiberRoot, finishedWork: Fiber, committedLanes: Lanes ) { inProgressLanes = committedLanes; inProgressRoot = root; // mutation阶段的执行顺序也是自上而下开始遍历，执行删除dom操作，然后到了最底层子节点， // 开始自下而上执行插入和更新dom操作 commitMutationEffectsOnFiber(finishedWork, root, committedLanes); inProgressLanes = null; inProgressRoot = null; } function commitMutationEffectsOnFiber( finishedWork: Fiber, root: FiberRoot, lanes: Lanes ) { const current = finishedWork.alternate; const flags = finishedWork.flags; // The effect flag should be checked *after* we refine the type of fiber, // because the fiber tag is more specific. An exception is any flag related // to reconcilation, because those can be set on all fiber types. switch (finishedWork.tag) { case FunctionComponent: case ForwardRef: case MemoComponent: case SimpleMemoComponent: { // Deletion 深度遍历执行删除操作 recursivelyTraverseMutationEffects(root, finishedWork, lanes); // Placement 插入逻辑 commitReconciliationEffects(finishedWork); if (flags \u0026amp; Update) { // 找出 useInsertionEffect 的 destroy 方法去调用 // 需要注意 destroy 可能为 undefined（函数组件初次挂载的情况下） commitHookEffectListUnmount( HookInsertion | HookHasEffect, finishedWork, finishedWork.return, ); // 执行 useInsertionEffect 的回调函数，并将返回值保存到 effect.destory 里。 commitHookEffectListMount( HookInsertion | HookHasEffect, finishedWork, ); if ( enableProfilerTimer \u0026amp;\u0026amp; enableProfilerCommitHooks \u0026amp;\u0026amp; finishedWork.mode \u0026amp; ProfileMode ) { startLayoutEffectTimer(); // useLayoutEffect 对应的 destroy 方法 // 同样可能不存在 commitHookEffectListUnmount( HookLayout | HookHasEffect, finishedWork, finishedWork.return, ); recordLayoutEffectDuration(finishedWork); } } return; } case HostComponent: { recursivelyTraverseMutationEffects(root, finishedWork, lanes); commitReconciliationEffects(finishedWork); } } 流程图 # commit 流程图 ","date":"2025-01-17","externalUrl":null,"permalink":"/react/commit/","section":"Reacts","summary":"commit阶段 处理 fiber 创建/更新 遗留的 副作用 值得一提的是 useEffect 在该阶段会通过 microTask 方式放到微任务队列等待当前同步代码执行完成后再执行","title":"React18 阅读笔记 -- commit","type":"react"},{"content":"","date":"2025-01-13","externalUrl":null,"permalink":"/tags/formily/","section":"Tags","summary":"","title":"Formily","type":"tags"},{"content":" Formily 简介 # Formily 是一款专注于解决中台表单场景的 JavaScript 库，具备高性能、支持多种前端框架等优势，能够轻松应对复杂的表单业务需求。它将表单的逻辑和视图进行分离，使得表单开发更加高效和可维护。例如，在一个大型企业级应用中，涉及到各种复杂的表单交互，Formily 可以很好地处理这些场景，提升开发效率和用户体验。\n使用场景 # 由于 formily 可以通过配置 json schema 渲染表单，因此可以很方便的复用表单内部逻辑，而适配不同端 UI 则交给 UI 层，下面是一些 formily 能力的基本使用\n表单联动 # 在复杂表单中，表单联动是常见的需求。比如，当用户选择省份后，城市下拉框会自动更新为该省份对应的城市。以下是使用 Formily 实现表单联动的示例代码：\nimport React, { useState } from \u0026#34;react\u0026#34;; import { createForm } from \u0026#34;@formily/core\u0026#34;; import { FormProvider, Field } from \u0026#34;@formily/react\u0026#34;; import { Select } from \u0026#34;antd\u0026#34;; const { Option } = Select; // 模拟省份和城市数据 const provinceCityMap = { 北京: [\u0026#34;东城区\u0026#34;, \u0026#34;西城区\u0026#34;, \u0026#34;朝阳区\u0026#34;], 上海: [\u0026#34;黄浦区\u0026#34;, \u0026#34;徐汇区\u0026#34;, \u0026#34;长宁区\u0026#34;] }; const form = createForm(); const provinces = Object.keys(provinceCityMap); const ProvinceCityForm = () =\u0026gt; { const [selectedProvince, setSelectedProvince] = useState(\u0026#34;\u0026#34;); const handleProvinceChange = (value) =\u0026gt; { setSelectedProvince(value); form.setFieldValue(\u0026#34;city\u0026#34;, \u0026#34;\u0026#34;); }; return ( \u0026lt;FormProvider form={form}\u0026gt; \u0026lt;Field name=\u0026#34;province\u0026#34;\u0026gt; \u0026lt;Select placeholder=\u0026#34;请选择省份\u0026#34; onChange={handleProvinceChange}\u0026gt; {provinces.map((province) =\u0026gt; ( \u0026lt;Option key={province} value={province}\u0026gt; {province} \u0026lt;/Option\u0026gt; ))} \u0026lt;/Select\u0026gt; \u0026lt;/Field\u0026gt; \u0026lt;Field name=\u0026#34;city\u0026#34;\u0026gt; \u0026lt;Select placeholder=\u0026#34;请选择城市\u0026#34;\u0026gt; {selectedProvince \u0026amp;\u0026amp; provinceCityMap[selectedProvince].map((city) =\u0026gt; ( \u0026lt;Option key={city} value={city}\u0026gt; {city} \u0026lt;/Option\u0026gt; ))} \u0026lt;/Select\u0026gt; \u0026lt;/Field\u0026gt; \u0026lt;/FormProvider\u0026gt; ); }; 异步数据源 # 当表单中需要使用异步数据源时，Formily 可以通过useAsync等方法来处理数据加载和更新。例如，从后端获取用户列表并展示在下拉框中：\nimport React from \u0026#34;react\u0026#34;; import { createForm } from \u0026#34;@formily/core\u0026#34;; import { FormProvider, Field } from \u0026#34;@formily/react\u0026#34;; import { Select } from \u0026#34;antd\u0026#34;; import axios from \u0026#34;axios\u0026#34;; const { Option } = Select; const form = createForm(); const UserSelectForm = () =\u0026gt; { const [users, setUsers] = React.useState([]); const [loading, setLoading] = React.useState(false); React.useEffect(() =\u0026gt; { setLoading(true); axios .get(\u0026#34;/api/users\u0026#34;) .then((response) =\u0026gt; { setUsers(response.data); }) .catch((error) =\u0026gt; { console.error(\u0026#34;Error fetching users:\u0026#34;, error); }) .finally(() =\u0026gt; { setLoading(false); }); }, []); return ( \u0026lt;FormProvider form={form}\u0026gt; \u0026lt;Field name=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;Select placeholder=\u0026#34;请选择用户\u0026#34; loading={loading}\u0026gt; {users.map((user) =\u0026gt; ( \u0026lt;Option key={user.id} value={user.id}\u0026gt; {user.name} \u0026lt;/Option\u0026gt; ))} \u0026lt;/Select\u0026gt; \u0026lt;/Field\u0026gt; \u0026lt;/FormProvider\u0026gt; ); }; 表单场景化 # 以卡片式表单为例，Formily 可以轻松实现这种场景。假设我们有一个用户信息卡片式表单：\nimport React from \u0026#34;react\u0026#34;; import { createForm } from \u0026#34;@formily/core\u0026#34;; import { FormProvider, Field } from \u0026#34;@formily/react\u0026#34;; import { Card, Input } from \u0026#34;antd\u0026#34;; const form = createForm(); const UserCardForm = () =\u0026gt; { return ( \u0026lt;FormProvider form={form}\u0026gt; \u0026lt;Card title=\u0026#34;用户信息\u0026#34;\u0026gt; \u0026lt;Field name=\u0026#34;name\u0026#34;\u0026gt; \u0026lt;Input placeholder=\u0026#34;姓名\u0026#34; /\u0026gt; \u0026lt;/Field\u0026gt; \u0026lt;Field name=\u0026#34;age\u0026#34;\u0026gt; \u0026lt;Input placeholder=\u0026#34;年龄\u0026#34; /\u0026gt; \u0026lt;/Field\u0026gt; \u0026lt;/Card\u0026gt; \u0026lt;/FormProvider\u0026gt; ); }; export default UserCardForm; JSON Schema 形式用法 # JSON Schema 规范 # JSON Schema 是一种用于规范 JSON 文件内容的协议，Formily 遵循 draft - 07 标准。它通过定义数据的结构、类型、格式等，来确保数据的一致性和有效性。\nschema 字段描述 # 以下是一个简单的 schema 示例：\nexport const schema = { type: \u0026#34;object\u0026#34;, title: \u0026#34;用户信息\u0026#34;, properties: { age: { type: \u0026#34;string\u0026#34;, // // 定义数据类型，如`string`、`number`、`object`等。 title: \u0026#34;年龄\u0026#34;, } name: { type: \u0026#34;string\u0026#34;, // // 定义数据类型，如`string`、`number`、`object`等。 title: \u0026#34;姓名\u0026#34;, // 用于描述字段的标题，通常在表单中显示为标签。 required: true, // 指定字段是否为必填项。 \u0026#34;x-component\u0026#34;: \u0026#34;Input\u0026#34;, // 表单项的组件 // 表单项的组件 props \u0026#34;x-component-props\u0026#34;: { // placeholder: \u0026#34;请\u0026#34; }, // 表单项的装饰器 \u0026#34;x-decorator\u0026#34;: \u0026#34;FormItem\u0026#34;, // schema 中主要的联动写法 \u0026#34;x-reactions\u0026#34;: [ { dependencies: [\u0026#34;age\u0026#34;], fulfill: { // TODO schema 与 state 使用的场景的区别 // schema: { // \u0026#34;x-visible\u0026#34;: \u0026#34;{{ $deps[0] === \u0026#39;sex\u0026#39; }}\u0026#34; // 控制字段显示与隐藏 // }, state: { visible: \u0026#34;{{ $deps[0] \u0026gt;= 18 }}\u0026#34; }, disabled: false, // 控制字段禁用与启用 // 设置字段值,可以是具体的值，也可以是一个函数 value: (val: any) =\u0026gt; { return val; }, validate: true, // 触发表单校验 // 执行副作用函数，比如异步请求、日志记录等。 sideEffects: () =\u0026gt; { console.log(\u0026#34;依赖字段 selectOptions 变更\u0026#34;); }, setProps: \u0026#34;\u0026#34; } }, // 也可以直接写方法执行 (field: Field) =\u0026gt; { console.log(\u0026#34;field\u0026#34;, field); const age = field.query(\u0026#34;.age\u0026#34;).value(); if (age \u0026gt;= 18) { // field.setComponentProps({}); field.setValue(\u0026#34;1\u0026#34;); } else { field.setComponentProps({ placeholder: \u0026#39;未满18岁\u0026#39; }); // field.setValue(undefined); } } ] } } }; 其中 x-component、x-component-props、x-decorator 均为 UI 组件相关属性，可参考 antd 的实现 @formily/antd-v5\n应用示例 # 结合上述 schema，使用 Formily 创建表单的示例代码如下：\nimport React from \u0026#34;react\u0026#34;; import { createForm } from \u0026#34;@formily/core\u0026#34;; import { FormProvider, createSchemaField } from \u0026#34;@formily/react\u0026#34;; import { Input, NumberPicker } from \u0026#34;antd\u0026#34;; import { schema } from \u0026#34;./schema.js\u0026#34;; const form = createForm(); const SchemaField = createSchemaField({ components: { Input } }); const UserInfoSchemaForm = () =\u0026gt; { return ( \u0026lt;FormProvider form={form}\u0026gt; \u0026lt;SchemaField schema={schema} /\u0026gt; \u0026lt;/FormProvider\u0026gt; ); }; 在 React 中的使用 # 准备工作 # 在 React 项目中使用 Formily，需要安装以下依赖包：\npnpm install @formily/core @formily/react @formily/antd-v5 基本使用 # 下面是一个简单的 React 表单示例，展示 Formily 的基本使用方法：\nimport { createForm } from \u0026#34;@formily/core\u0026#34;; import { FormProvider } from \u0026#34;@formily/react\u0026#34;; import { FormItem, Input } from \u0026#34;@formily/antd-v5\u0026#34;; import { Button } from \u0026#34;antd\u0026#34;; // 创建表单实例 const form = createForm(); export default () =\u0026gt; { return ( \u0026lt;FormProvider form={form}\u0026gt; \u0026lt;FormItem label=\u0026#34;用户名\u0026#34; labelCol={6} style={{ width: \u0026#34;240px\u0026#34; }}\u0026gt; \u0026lt;Input name=\u0026#34;username\u0026#34; placeholder=\u0026#34;请输入用户名\u0026#34; /\u0026gt; \u0026lt;/FormItem\u0026gt; \u0026lt;FormItem label=\u0026#34;密码\u0026#34; labelCol={6} style={{ width: \u0026#34;240px\u0026#34; }}\u0026gt; \u0026lt;Input name=\u0026#34;password\u0026#34; type=\u0026#34;password\u0026#34; placeholder=\u0026#34;请输入密码\u0026#34; /\u0026gt; \u0026lt;/FormItem\u0026gt; \u0026lt;Button type=\u0026#34;primary\u0026#34; htmlType=\u0026#34;submit\u0026#34;\u0026gt; 提交 \u0026lt;/Button\u0026gt; \u0026lt;/FormProvider\u0026gt; ); }; 示例图 深入使用 # 自定义组件 # 假设我们有一个自定义的日期选择组件，如何在 Formily 中使用：\nimport React from \u0026#34;react\u0026#34;; import { createForm } from \u0026#34;@formily/core\u0026#34;; import { FormProvider, Field } from \u0026#34;@formily/react\u0026#34;; import { DatePicker } from \u0026#34;antd\u0026#34;; const form = createForm(); const MyDatePicker = React.forwardRef((props, ref) =\u0026gt; { return \u0026lt;DatePicker {...props} ref={ref} /\u0026gt;; }); const CustomComponentForm = () =\u0026gt; { return ( \u0026lt;FormProvider form={form}\u0026gt; \u0026lt;Field name=\u0026#34;date\u0026#34; component={MyDatePicker}\u0026gt; \u0026lt;MyDatePicker placeholder=\u0026#34;请选择日期\u0026#34; /\u0026gt; \u0026lt;/Field\u0026gt; \u0026lt;/FormProvider\u0026gt; ); }; export default CustomComponentForm; 表单校验 # 使用 Formily 进行表单校验，例如验证邮箱格式：\nimport React from \u0026#34;react\u0026#34;; import { createForm } from \u0026#34;@formily/core\u0026#34;; import { FormProvider, Field } from \u0026#34;@formily/react\u0026#34;; import { Input, Button } from \u0026#34;antd\u0026#34;; const form = createForm(); const validateEmail = (value) =\u0026gt; { const regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/; return regex.test(value); }; const ValidationForm = () =\u0026gt; { const handleSubmit = () =\u0026gt; { form .validate() .then((values) =\u0026gt; { console.log(\u0026#34;表单提交数据:\u0026#34;, values); }) .catch((error) =\u0026gt; { console.error(\u0026#34;表单验证失败:\u0026#34;, error); }); }; return ( \u0026lt;FormProvider form={form}\u0026gt; \u0026lt;Field name=\u0026#34;email\u0026#34; rules={[ { validator: (_, value) =\u0026gt; { if (!validateEmail(value)) { return Promise.reject(new Error(\u0026#34;请输入正确的邮箱格式\u0026#34;)); } return Promise.resolve(); } } ]} \u0026gt; \u0026lt;Input placeholder=\u0026#34;请输入邮箱\u0026#34; /\u0026gt; \u0026lt;/Field\u0026gt; \u0026lt;Button type=\u0026#34;primary\u0026#34; onClick={handleSubmit}\u0026gt; 提交 \u0026lt;/Button\u0026gt; \u0026lt;/FormProvider\u0026gt; ); }; export default ValidationForm; 表单状态管理 # 获取表单的状态，如是否有未保存的修改：\nimport React from \u0026#34;react\u0026#34;; import { createForm } from \u0026#34;@formily/core\u0026#34;; import { FormProvider, useForm } from \u0026#34;@formily/react\u0026#34;; import { Input, Button } from \u0026#34;antd\u0026#34;; const form = createForm(); const StatusManagementForm = () =\u0026gt; { const { form: formInstance } = useForm(); const handleSubmit = () =\u0026gt; { formInstance .validate() .then((values) =\u0026gt; { console.log(\u0026#34;表单提交数据:\u0026#34;, values); }) .catch((error) =\u0026gt; { console.error(\u0026#34;表单验证失败:\u0026#34;, error); }); }; React.useEffect(() =\u0026gt; { const unsubscribe = formInstance.subscribe((state) =\u0026gt; { console.log(\u0026#34;表单状态:\u0026#34;, state); if (state.dirty) { console.log(\u0026#34;表单有未保存的修改\u0026#34;); } }); return () =\u0026gt; { unsubscribe(); }; }, []); return ( \u0026lt;FormProvider form={form}\u0026gt; \u0026lt;Field name=\u0026#34;name\u0026#34;\u0026gt; \u0026lt;Input placeholder=\u0026#34;请输入姓名\u0026#34; /\u0026gt; \u0026lt;/Field\u0026gt; \u0026lt;Button type=\u0026#34;primary\u0026#34; onClick={handleSubmit}\u0026gt; 提交 \u0026lt;/Button\u0026gt; \u0026lt;/FormProvider\u0026gt; ); }; export default StatusManagementForm; reaction 源码解析 # 引入 reaction 的目的 # 在 Formily 的架构中，数据的响应式变化管理至关重要。reaction 机制的引入，旨在实现对数据状态变化的高效监听与响应，确保表单中各个组件能及时、准确地反映数据的更新，提升用户交互体验。例如，当表单中的某个字段值发生改变时，与之关联的其他字段或组件能够自动更新，这背后便是 reaction 在发挥作用。\n关键代码逻辑 # 在 Formily 的源码中，reaction 相关代码主要集中在核心模块。其核心逻辑基于依赖收集与发布订阅模式。当数据状态发生变化时，会触发依赖收集过程中记录的所有相关回调函数。\n// 简化的 reaction 实现示例 function reaction(trackFn, effectFn) { let dep = new Set(); let target = {}; // 依赖收集 let oldValue = track(target, trackFn); const cleanup = () =\u0026gt; { dep.forEach((fn) =\u0026gt; fn()); }; // 创建响应式副作用 const runner = () =\u0026gt; { let newValue = track(target, trackFn); if (newValue !== oldValue) { effectFn(newValue, oldValue, cleanup); oldValue = newValue; } }; runner(); return cleanup; } function track(target, fn) { let value; // 这里模拟触发 trackFn，在实际中会收集依赖 value = fn(); return value; } 在这段简化代码中，reaction函数接收两个参数：trackFn用于收集依赖，effectFn是在数据变化时执行的副作用函数。dep集合用于存储依赖，cleanup函数用于清除依赖。runner函数会在数据变化时执行effectFn，并更新旧值。\n核心功能实现 # 依赖收集：在数据读取阶段，Formily 会记录下当前读取数据的函数与数据之间的依赖关系。例如，当某个组件读取表单字段的值时，该组件的渲染函数就会被记录为该字段的依赖。\n变化通知：一旦数据状态发生改变，Formily 会遍历依赖列表，通知所有依赖该数据的组件或函数进行更新，确保整个表单的状态一致性。\n总结 # Formily 在前端表单开发中具有强大的功能和优势，通过本文档对其使用场景、JSON Schema 用法、React 集成以及 reaction 源码解析的介绍，开发者可以更全面地掌握 Formily 的使用方法，从而在实际项目中高效地开发复杂表单。在实际应用中，可根据具体需求灵活运用这些特性，不断优化表单的交互和性能。\n","date":"2025-01-13","externalUrl":null,"permalink":"/posts/formily/","section":"Posts","summary":"本文主要从\u003ccode\u003eformily\u003c/code\u003e简介、快速上手、生态、使用场景以及源码等方面介绍formily","title":"Formily 使用及源码简介","type":"posts"},{"content":"","date":"2025-01-13","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":" 快速上手 # Zustand 是基于 React Hook 构建的状态管理库，它的设计理念是让状态管理变得简单、直观。只需寥寥数行代码，就能轻松管理应用的状态。\n特点 # 轻量级：Zustand 的体积非常小，几乎没有任何依赖，生产级包体积不到 1kb，这使得它在项目中引入时不会带来过多的负担，能够保持项目的轻量化。 基于 React Hook：完全基于 React Hook 构建，契合函数式编程，开发者可以利用熟悉的 Hook 语法来管理状态，避免了复杂的类组件写法和样板代码。 简单易用：API 简洁明了，有完备的使用文档，源码清晰且不多，学习成本低、曲线顺畅。 高性能：能够精确地追踪状态的变化，只重新渲染依赖该状态的组件，从而提高应用的性能和响应速度。 可扩展性：支持中间件和插件机制，开发者可以根据项目需求轻松地扩展其功能，如添加日志记录、持久化状态等。 安装 Zustand # 使用 npm 或 yarn 安装 Zustand，为项目引入这个强大的状态管理工具：\nnpm install zustand # 或者 yarn add zustand 创建第一个状态 # 以一个简单的计数器为例，看看如何使用 Zustand 创建和管理状态：\nimport create from \u0026#34;zustand\u0026#34;; const useCounter = create((set) =\u0026gt; ({ count: 0, increment: () =\u0026gt; set((state) =\u0026gt; ({ count: state.count + 1 })), decrement: () =\u0026gt; set((state) =\u0026gt; ({ count: state.count - 1 })) })); 在这段代码中，create函数接收一个回调函数，通过set方法来更新状态。set方法既可以接收一个新的状态对象，也可以接收一个函数，该函数接收当前状态并返回新状态，确保状态更新的不可变性。\n在 React 使用 # 在 React 中，通过useCounter这个自定义 Hook 来获取和更新状态：\nimport React from \u0026#34;react\u0026#34;; import useCounter from \u0026#34;./useCounter\u0026#34;; const CounterComponent = () =\u0026gt; { const { count, increment, decrement } = useCounter(); // const increment = useCounter((state) =\u0026gt; state.increment); // const decrement = useCounter((state) =\u0026gt; state.decrement); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={increment}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;button onClick={decrement}\u0026gt;Decrement\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export default CounterComponent; 这里使用useCounter的回调函数，精准地获取和操作所需的状态。这种方式被称为“selector”，它可以只返回组件关心的状态部分，避免不必要的重新渲染，极大地提升了性能。\n处理复杂状态 # 复杂状态管理与 Immer 的结合 # 当处理复杂的状态结构时，Zustand 可以与 Immer 库结合使用，让状态更新变得更加简洁和直观。Immer 允许我们以可变的方式编写代码，而底层会自动处理不可变数据的更新。\nimport create from \u0026#34;zustand\u0026#34;; import produce from \u0026#34;immer\u0026#34;; const useTodoStore = create((set) =\u0026gt; ({ todos: [], addTodo: (text) =\u0026gt; set( produce((state) =\u0026gt; { state.todos.push({ id: Date.now(), text, completed: false }); }) ), toggleTodo: (id) =\u0026gt; set( produce((state) =\u0026gt; { const todo = state.todos.find((t) =\u0026gt; t.id === id); if (todo) { todo.completed = !todo.completed; } }) ) })); 通过 Immer 的produce函数，我们可以像操作普通对象一样更新状态，而无需手动处理复杂的不可变数据结构。\n中间件 # Zustand 支持中间件，通过中间件可以轻松扩展状态管理的功能。例如，使用zustand - middleware - logger中间件来记录状态的变化，方便调试：\nnpm install zustand-middleware-logger # 或者 yarn add zustand-middleware-logger import create from \u0026#34;zustand\u0026#34;; import logger from \u0026#34;zustand-middleware-logger\u0026#34;; const useCounter = create( logger((set) =\u0026gt; ({ count: 0, increment: () =\u0026gt; set((state) =\u0026gt; ({ count: state.count + 1 })), decrement: () =\u0026gt; set((state) =\u0026gt; ({ count: state.count - 1 })) })) ); 添加中间件后，每次状态更新时，控制台都会输出详细的日志信息，帮助我们快速定位问题。\n源码浅析（react 部分） # create # create函数是 Zustand 的核心，它负责创建状态管理实例。其基本实现思路是创建一个包含状态和更新方法的对象，并返回一个自定义 Hook。这个 Hook 内部维护了一个状态的订阅者列表，当状态发生变化时，会通知所有订阅者重新渲染。\nfunction create(setter) { let state; let listeners = new Set(); const setState: StoreApi\u0026lt;TState\u0026gt;[\u0026#39;setState\u0026#39;] = (partial, replace) =\u0026gt; { const nextState = typeof partial === \u0026#39;function\u0026#39; ? (partial as (state: TState) =\u0026gt; TState)(state) : partial if (!Object.is(nextState, state)) { const previousState = state state = (replace ?? (typeof nextState !== \u0026#39;object\u0026#39; || nextState === null)) ? (nextState as TState) : Object.assign({}, state, nextState) listeners.forEach((listener) =\u0026gt; listener(state, previousState)) } } const getState: StoreApi\u0026lt;TState\u0026gt;[\u0026#39;getState\u0026#39;] = () =\u0026gt; state const subscribe: StoreApi\u0026lt;TState\u0026gt;[\u0026#39;subscribe\u0026#39;] = (listener) =\u0026gt; { listeners.add(listener) // Unsubscribe return () =\u0026gt; listeners.delete(listener) } const getInitialState: StoreApi\u0026lt;TState\u0026gt;[\u0026#39;getInitialState\u0026#39;] = () =\u0026gt; initialState const initialState = setter(setState); const api = { setState, getState, getInitialState, subscribe } const initialState = (state = createState(setState, getState, api)) return api as any } 在这个简化的实现中， create函数接收一个setter函数，通过setState方法来更新状态，并通知所有订阅者。返回的自定义 Hook 则负责根据selector获取状态，并在状态变化时重新计算selector的值。\nuseStore Hook # useStore Hook 是 Zustand 与 React 组件交互的桥梁。它通过 React 的useState和useEffect Hook 来实现状态的订阅和更新。当组件使用useStore时，会将自身添加到状态的订阅者列表中，当状态发生变化时，会触发组件的重新渲染。\nimport { useSyncExternalStore } from \u0026#34;react\u0026#34;; const identity = \u0026lt;T\u0026gt;(arg: T): T =\u0026gt; arg; export function useStore\u0026lt;TState, StateSlice\u0026gt;( api: ReadonlyStoreApi\u0026lt;TState\u0026gt;, selector: (state: TState) =\u0026gt; StateSlice = identity as any ) { const slice = useSyncExternalStore( api.subscribe, () =\u0026gt; selector(api.getState()), () =\u0026gt; selector(api.getInitialState()) ); React.useDebugValue(slice); return slice; } 在实际的 Zustand 源码中，useStore的实现更加复杂，它还处理了selector的缓存、中间件的调用等功能，但基本原理与上述代码类似。\n总结 # Zustand 以其简洁的 API、高效的性能和灵活的扩展性，为 React 开发者提供了一种优秀的状态管理解决方案。通过深入了解 Zustand 在 React 中的使用方法和源码实现，我们不仅能够更好地运用这一工具，还能从中汲取设计灵感，提升自己的编程能力。\n在未来，随着 React 生态的不断发展，相信 Zustand 也会持续演进，为开发者带来更多便利和惊喜。无论是小型项目的快速迭代，还是大型应用的复杂状态管理，Zustand 都值得我们深入学习和使用。\n希望本文能帮助你对 Zustand 有更深入的理解，如果你在使用 Zustand 的过程中有任何问题或心得，欢迎在评论区分享交流！\n","date":"2025-01-13","externalUrl":null,"permalink":"/posts/zustand/","section":"Posts","summary":"文章主要介绍了Zustand这一React状态管理库，包括其简介、优势、使用方法、与Redux对比、踩坑点、中间件、选择理由、工作原理等。Zustand轻量简洁，API友好，支持TypeScript，具有性能优化、灵活可扩展等优点，可轻松集成和处理异步操作，能完美替代某些传统状态管理库的不足，在实际使用中有多种优化和配置方式。","title":"React 中使用 Zustand 状态管理库 及其源码解析","type":"posts"},{"content":" New article! ReactDOM.createRoot # 创建了一个 reactfiberrootnode current 属性指向一个新 fiber,并绑定所有事件监听\n/** * 创建 tag = 1 的 FiberRoot 对象 * 并在current 上挂载了一个 tag = 3, mode = 1 的空fiber * 初始化该 fiber 的 UpdateQueue initializeUpdateQueue(uninitializedFiber) */ const root = createContainer( container, ConcurrentRoot, // 常量 1 null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks, ); // container[__reactContainer$(一串随机数)] = root.current; markContainerAsRoot(root.current, container); const rootContainerElement: Document | Element | DocumentFragment = container.nodeType === COMMENT_NODE ? (container.parentNode: any) : container; /** 为 container 添加事件监听 */ listenToAllSupportedEvents(rootContainerElement); /** * this._internalRoot = internalRoot; * 挂载到 ReactDOMRoot._internalRoot 属性上 */ return new ReactDOMRoot(root); render 入口 # // path: packages/react-dom/src/client/ReactDomRoot.js ReactDOMRoot.prototype.render = function (children: ReactNodeList): void { // ...省略部分代码 updateContainer(children, root, null, null); }; // path: packages/react-reconciler/src/ReactFiberReconciler.old.js function updateContainer( element: ReactNodeList, // Index container: OpaqueRoot, // root parentComponent: ?React$Component\u0026lt;any, any\u0026gt;, // null callback: ?Function // null ): Lane { // 初始化一个 update 任务 const update = createUpdate(eventTime, lane); update.payload = { element }; /** * 将创建的 update任务 添加到 ReactFiberConcurrentUpdates 文件 * 全局变量 concurrentQueues 中 * 用传入的 lane 更新fiber链表中的所有 lane 并返回 root * */ const fiber = container.current; const queue: SharedQueue\u0026lt;State\u0026gt; = fiber.updateQueue.shared; const interleaved = queue.interleaved; if (interleaved === null) { update.next = update; ReactFiberConcurrentUpdates.concurrentQueues = [queue]; } queue.interleaved = update; // 上面是 enqueueUpdate 方法的具体实现 执行栈太长就把重要步骤挪过来方便查看了 const root = markUpdateLaneFromFiberToRoot(fiber, lane); if (root !== null) { scheduleUpdateOnFiber(root, current, lane, eventTime); entangleTransitions(root, current, lane); } } scheduleUpdateOnFiber # // path: packages/react-reconciler/src/ReactFiberWorkLoop.old.js function scheduleUpdateOnFiber( root: FiberRoot, fiber: Fiber, lane: Lane, eventTime: number ) { // 将 eventTime 按 lane 插入到 root.eventTimes 中 markRootUpdated(root, lane, eventTime); // 做的事情蛮多 ensureRootIsScheduled(root, eventTime); } // ensureRootIsScheduled function ensureRootIsScheduled(root: FiberRoot, currentTime: number) { //根据 root.eventTimes 计算出 root.expirationTimes markRootUpdated(root, lane, eventTime); const nextLanes = getNextLanes(root, NoLanes); const newCallbackPriority = getHighestPriorityLane(nextLanes); const existingCallbackNode = root.callbackNode; if (existingCallbackNode != null) { // Cancel the existing callback. We\u0026#39;ll schedule a new one below. cancelCallback(existingCallbackNode); } let newCallbackNode = scheduleCallback( schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root) ); root.callbackPriority = newCallbackPriority; root.callbackNode = newCallbackNode; } scheduleCallback # 通过 postMessage 建立一个 宏任务 启动挂载\nfunction scheduleCallback(priorityLevel, callback) { // 这里调用的就是 Scheduler 中的 unstable_scheduleCallback 方法 return Scheduler_scheduleCallback(priorityLevel, callback); } // path: packages/scheduler/src/forks/Scheduler.js function unstable_scheduleCallback(priorityLevel, callback, options) { var currentTime = getCurrentTime(); var startTime = currentTime; // NormalPriority 是 5000 var timeout = 5000; var expirationTime = startTime + timeout; var newTask = { id: taskIdCounter++, callback, // performConcurrentWorkOnRoot 方法 priorityLevel, startTime, expirationTime, sortIndex: -1 }; newTask.sortIndex = expirationTime; // 将 newTask 放进 taskQueue 并按照 sortIndex 排序 push(taskQueue, newTask); // 挂载时都为初始值 false if (!isHostCallbackScheduled \u0026amp;\u0026amp; !isPerformingWork) { isHostCallbackScheduled = true; function requestHostCallback(callback) { scheduledHostCallback = callback; // 挂载时都为初始值 false if (!isMessageLoopRunning) { isMessageLoopRunning = true; // 通过 postMessage 异步调用 performWorkUntilDeadline schedulePerformWorkUntilDeadline(); } } requestHostCallback(flushWork); } } // path: packages/scheduler/src/forks/Scheduler.js const performWorkUntilDeadline = () =\u0026gt; { const currentTime = getCurrentTime(); let hasMoreWork = true; try { // 这里的 scheduledHostCallback 就是 flushWork hasMoreWork = scheduledHostCallback(true, currentTime); } finally { // 还有任务则再调一轮 if (hasMoreWork) { schedulePerformWorkUntilDeadline(); } else { isMessageLoopRunning = false; scheduledHostCallback = null; } } }; flushWork # 循环调度 宏任务（挂载时只 push 了 一个 task）\n// path: packages/scheduler/src/forks/Scheduler.js // hasTimeRemaining = true ,initialTime = currentTime function flushWork(hasTimeRemaining, initialTime) { isHostCallbackScheduled = false; isPerformingWork = true; // 这里的 currentPriorityLevel 为初始值 3 const previousPriorityLevel = currentPriorityLevel; try { return workLoop(hasTimeRemaining, initialTime); } finally { currentTask = null; currentPriorityLevel = previousPriorityLevel; isPerformingWork = false; if (enableProfiling) { const currentTime = getCurrentTime(); markSchedulerSuspended(currentTime); } } } // path: packages/scheduler/src/forks/Scheduler.js function workLoop(hasTimeRemaining, initialTime) { let currentTime = initialTime; currentTask = peek(taskQueue); while (currentTask !== null) { // 这里的 callback 就是 performConcurrentWorkOnRoot const callback = currentTask.callback; if (typeof callback === \u0026#34;function\u0026#34;) { currentTask.callback = null; currentPriorityLevel = currentTask.priorityLevel; const didUserCallbackTimeout = currentTask.expirationTime \u0026lt;= currentTime; // 至此 任务调度 完成，开始执行任务 进入 reconciler 阶段 const continuationCallback = callback(didUserCallbackTimeout); currentTime = getCurrentTime(); if (typeof continuationCallback === \u0026#34;function\u0026#34;) { currentTask.callback = continuationCallback; } else { if (currentTask === peek(taskQueue)) { pop(taskQueue); } } } } } performConcurrentWorkOnRoot # 调用 workLoopSync 开始 递归创建 fiber\n// path: packages/react-reconciler/src/ReactFiberWorkLoop.old.js function performConcurrentWorkOnRoot(root, didTimeout) { const originalCallbackNode = root.callbackNode; /** 刷新pending状态的effects, 有可能某些effect会取消本次任务 */ const didFlushPassiveEffects = flushPassiveEffects(); let lanes = getNextLanes(root, NoLanes); let exitStatus = renderRootSync(root, lanes); if (![0, 1, 2, 6].includes(exitStatus)) { root.finishedWork = finishedWork; root.finishedLanes = lanes; // !调和阶段完成 提交fiber树 finishConcurrentRender(root, exitStatus, lanes); } ensureRootIsScheduled(root, now()); // 若还是同一个任务则继续返回该任务 if (root.callbackNode === originalCallbackNode) { return performConcurrentWorkOnRoot.bind(null, root); } return null; } function renderRootSync(root: FiberRoot, lanes: Lanes) { // 存储 executionContext const prevExecutionContext = executionContext; // 将 executionContext 更新为 RenderContext executionContext |= RenderContext; ReactCurrentDispatcher.current = ContextOnlyDispatcher; // 如果workinprogress不存在 则初始化一个 // 并将 queue.interleaved 移到 queue.pending 中 // 这里的 queue 存的是 root.current.updateQueue.shared // 在 enqueueConcurrentClassUpdate 方法中给 queue.interleaved 赋值为 update; // 该update 是在 updateContainer 方法中 创建的 并将 payload属性赋值为了 render方法里的 第一个参数 prepareFreshStack(root, lanes); do { try { workLoopSync(); break; } catch (thrownValue) { handleError(root, thrownValue); } } while (true); return workInProgressRootExitStatus; } function workLoopSync() { while (workInProgress !== null) { performUnitOfWork(workInProgress); } } performUnitOfWork # 进入到最小调度单元，递归创建 fiber 并链接到workinprogress\nfunction performUnitOfWork(unitOfWork: Fiber): void { const current = unitOfWork.alternate; let next; // 用来存放beginWork()返回的结果 // 根据 workInProgress.tag 创建对应 fiber // 若 为 函数组件 则调用 renderWidthHook 执行函数组件 并 创建对应fiber next = beginWork(current, unitOfWork, subtreeRenderLanes); // 更新状态了 unitOfWork.memoizedProps = unitOfWork.pendingProps; if (next === null) { // If this doesn\u0026#39;t spawn new work, complete the current work. completeUnitOfWork(unitOfWork); } else { // 下次的workLoopSync/workLoopConcurrent的while循环的循环主体为子Fiber节点 workInProgress = next; } } function completeUnitOfWork(unitOfWork: Fiber): void { // 本次 performUnitOfWork 的循环主体 workInprogress 的最底层 child let completedWork = unitOfWork; do { const current = completedWork.alternate; const returnFiber = completedWork.return; // 只要 beginWork 阶段正常执行后（即执行无异常），都会进到这一段逻辑来 let next; next = completeWork(current, completedWork, subtreeRenderLanes); resetCurrentDebugFiberInDEV(); if (next !== null) { workInProgress = next; return; } // 取当前Fiber节点(completedWork)的兄弟(sibling)节点； // 如果有值，则结束completeUnitOfWork，并将该兄弟节点作为下次performUnitOfWork的主体(unitOfWork) const siblingFiber = completedWork.sibling; if (siblingFiber !== null) { // If there is more work to do in this returnFiber, do that next. workInProgress = siblingFiber; return; } // Otherwise, return to the parent // 若没有兄弟节点，则将在下次do...while循环中处理父节点(completedWork.return) completedWork = returnFiber; // Update the next thing we\u0026#39;re working on in case something throws. // 此处需要注意！ // 虽然把workInProgress置为completedWork，但由于没有return，即没有结束completeUnitOfWork，因此没有意义 // 直到completedWork（此时实际上是本循环中原completedWork.return）为null，结束do...while循环后 // 此时completeUnitOfWork的运行结果(workInProgress)为null // 也意味着performSyncWorkOnRoot/performConcurrentWorkOnRoot中的while循环也达到了结束条件 workInProgress = completedWork; } while (completedWork !== null); // We\u0026#39;ve reached the root. if (workInProgressRootExitStatus === RootInProgress) { workInProgressRootExitStatus = RootCompleted; } } finishConcurrentRender # wrokinprogress树创建完成 开始 commit\nfinishConcurrentRender(root, exitStatus, lanes) { switch (exitStatus) { case RootCompleted: { // The work completed. Ready to commit. commitRoot( root, workInProgressRootRecoverableErrors, workInProgressTransitions, ) break; } } } function commitRootImpl( root: FiberRoot, recoverableErrors: null | Array\u0026lt;CapturedValue\u0026lt;mixed\u0026gt;\u0026gt;, transitions: Array\u0026lt;Transition\u0026gt; | null, renderPriorityLevel: EventPriority, ) { do { flushPassiveEffects() } while (rootWithPendingPassiveEffects !== null); const finishedWork = root.finishedWork; const lanes = root.finishedLanes; root.finishedWork = null; root.finishedLanes = NoLanes; root.callbackNode = null; root.callbackPriority = NoLane; if (!rootDoesHavePassiveEffects) { rootDoesHavePassiveEffects = true; pendingPassiveEffectsRemainingLanes = remainingLanes; pendingPassiveTransitions = transitions; scheduleCallback(NormalSchedulerPriority, () =\u0026gt; { flushPassiveEffects(); return null; }); } if (subtreeHasEffects || rootHasEffect) { const shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects( root, finishedWork, ); } } ","date":"2025-01-13","externalUrl":null,"permalink":"/react/render%E8%B0%83%E5%BA%A6/","section":"Reacts","summary":"从 render 入口函数 开始 debug react18 源码，梳理 主体流程 有哪些步骤","title":"React18 阅读笔记 -- render 调度阶段","type":"react"},{"content":"","date":"2025-01-13","externalUrl":null,"permalink":"/tags/zustand/","section":"Tags","summary":"","title":"Zustand","type":"tags"},{"content":"","date":"2025-01-13","externalUrl":null,"permalink":"/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/","section":"Tags","summary":"","title":"状态管理","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]