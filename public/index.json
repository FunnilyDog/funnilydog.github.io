


[{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/","section":"FunnilyDog‘s Site","summary":"","title":"FunnilyDog‘s Site","type":"page"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/notes/","section":"Notes","summary":"","title":"Notes","type":"notes"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":" pnpm npm yarn # pnpm 通过硬链接、冗余移除、压缩存储、并行安装和锁定文件等机制，实现了高效、可共享的依赖管理方式，有效地减少了磁盘空间占用和重复下载的问题，并提高了安装速度\npnpm 使用符号链接 Symbolic link（软链接）来创建依赖项的嵌套结构，将项目的直接依赖符号链接到 node_modules 的根目录， 直接依赖的实际位置在.pnpm/@/node_modules/， 依赖包中的每个文件再硬链接（Hard link）到.pnpm store\nnpm yarn 会在每个 node_modules 目录为所有依赖项村粗完整文件副本，如果有相同依赖 则会被重复存储。 采用扁平依赖树来管理依赖包，解决依赖嵌套层级过深 以及重复安装 问题\nCommonjs(node) 和 es nodule 模块化 导入导出的区别 # CommonJs # 关键字：导入 require 导出 module.exports / exports 可以导出任意类型，为同步加载模块 因此不适用于浏览器（若某个模块加载很慢会导致页面假死）。 CommonJs如何避免循环导入： 首先加载之后的文件的 module 会被缓存到 Module 上，比如一个模块已经 require 引入了 a 模块，如果另外一个模块再次引用 a ，那么会直接读取缓存值 module ，所以无需再次执行模块 module.exports / exports 区别： 如果我们不想在 commonjs 中导出对象，而是只导出一个类或者一个函数再或者其他属性的情况，那么 module.exports 就更方便 exports 会被初始化成一个对象，也就是我们只能在对象上绑定属性 ES Module # 关键字: 导入 import 导出 export / export defult ES6 module 的引入和导出是静态的,可导出任意类型，可默认导出某个属性，导入导出时可用 as 关键字 重命名 导入导出属性。也可用于node 模块化 ES Module 避免循环依赖： ES Module借助模块地图，已经进入过的模块标注为获取中，遇到import语句会去检查这个地图，已经标注为获取中的则不会进入，地图中的每一个节点是一个模块记录，上面有导出变量的内存地址，导入时会做一个连接——即指向同一块内存。 import() 动态引入: import() 返回一个 Promise 对象， 返回的 Promise 的 then 成功回调中，可以获取模块的加载成功信息。 浏览器内核 # 渲染引擎 # 解析HTML、CSS Trident: IE浏览器、百度浏览器 Gecko: Firefox浏览器 Blink: Opera浏览器、Chrome浏览器、Edge浏览器 Webkit: Safari浏览器 解决渲染引擎引起的兼容问题：Normalize.css JS 引擎 # 常见引擎及所在浏览器 Chakra:微软开发，用于IE浏览器 JavaScriptCore:WebKit中的JavaScript引擎，Apple公司开发 V8:Google开发的强大JavaScript引擎，也帮助Chrome从众多浏览器中脱颖而出 v8引擎执行过程： 进行Parser (词法分析，语法分析)成抽象 AST 树 AST 通过 Ignition（理解成解释器或者转化器）生成 bytecode(字节码)，js 实现跨平台的关键点 最后根据运行环境，自动将字节码转成对应的汇编代码-\u0026gt;机器码，由 CPU 执行 垃圾回收机制 # 浏览器垃圾回收机制 # 引用计数: 跟踪记录每个引用类型被使用的次数，赋值+1，变更-1，当引用计数为 0 时被回收\n弊端：循环引用将不可被清除、需要开辟新内存存储引用计数\n标记清除： 为程序中所有的变量添加上一个二进制字符(二进制运算最快)并初始值置为 0(默认全是垃圾)，然后遍历所有的对象，被使用的变量标记置为 1，所有被标记置为 1 的变量所引用的变量也置为 1，在程序运行结束时回收掉所有标记为零的变量，回收结束之后将现存变量标记统一置为 0，等待下一轮回收开启。\n弊端：耗时，产生内存碎片\nV8 垃圾回收优化 # 分代式 # V8 将内存空间划分为 新生代 和 老生代 . 新生代存储新产生的(存活时间较短)较小的对象，其内存空间通常只有 1 ～ 8M . 新生代会被拆分为使用区和空闲区，新的对象都会被分配到使用区，当使用区快满时则进行新生代区域的垃圾回收： 对使用区的活动对象进行标记，标记完成后将活跃对象复制到空闲区并排序，随后对使用区进行清理，最后将使用区与空闲区对换。\n· 当一个对象被多次复制还未被清理掉，故此对象会被认定为生命周期较长的对象，会被从新生代移动到老生代中 · 老生代存储着较大或生命周期较长的对象，对老生代垃圾回收则使用标记整理算法\n优化 # \u0026ndash; V8 在垃圾回收时会同时开启多个辅助线程进行并行回收 \u0026ndash; V8 会在标记阶段采用三色标记法进行切片处理（标记开始时所有对象都为白色，从跟对象开始将可达位置标记为灰色，若中断标记，后续直接从灰色继续开始同时将灰色置为黑色同时将下一代对象置为灰色，直至无可标记为灰色对象为止便 开始清除），为保障切片过程中已标记过的对象产生的新对象未被标记，会强制判断一旦有黑色的对象引用白色的对象，就会强制将被引用的白色变量标记为灰色。\n\u0026ndash; V8 标记完成后，如果内存足够便不会立即进行清理。\nMVVM MVC MVP # MVC # . Model: 主要管理业务模型的数据和行为，它既保存程序的数据，也定义了处理该数据的逻辑 . View: 接收用户的交互请求并展示数据信息给用户 . Controller: View 接收到用户的交互请求之后，会将请求转发给 Controller， Controller 解析用户的请求之后，就会交给对应的 Model 去处理 MVP # 三件套各自的职责和依赖关系和变种 MVC 里的职责和依赖关系其实是一样的， 但不同的是，MVP 之间的交互主要是通过接口实现的，Model、View、Presenter 都有各自的接口，降低模块之间的耦合性，便于进行单元测试了，维护性和扩展性也提高了。 但是 需要编写的代码量变多，需要对业务模块之前的交互抽象成借口定义，对开发的设计能力要求高。 MVVM # MVVM 最重要的一个特性就是数据绑定，通过将 View 的属性绑定到 ViewModel， 可以使两者之间松耦合，也完全不需要在 ViewModel 里写代码去直接更新一个 View . ViewModel: 视图模型，封装的是视图的表示逻辑和数据， 是对视图的抽象，包括视图的属性和命令，或视图的状态和行为。 总结: MVP 和 MVVM 都是为了解决界面和数据的分离问题，两者只是采用了不同的实现方案。 MVP 之间的交互主要是通过接口实现的，其主要弊端就是需要编写大量接口。 MVVM 则是通过数据绑定的方式实现交互，虽然其实现需要依赖具体的一些框架工具， 但明显大大减少了开发者需要编写的代码量。\nTree Shakig # 利用es module 静态引用的特性，在打包时从entry入口出发扫描所有依赖形成抽象语法树，随后运行所有代码，并打标，最后将没有被用到的代码消除掉。 jwt 实现 登录 tooken # jwt(JSON Web Token) 是一种开放标准，用于在各方之间安全传输信息。主要用于身份验证和授权。\nJWT 组成： 头部、负载、签名三部分，之间用.分割。 # 头部：主要描述 JWT 的元数据，包括令牌类型，加密算法等。 负载：数据声明部分，主要包含用户或其他实体信息，如 用户 id，用户名等。有 3 种声明类型：注册声明（JWT 规范中预定义的声明），公共声明（用户自定义的声明），私有声明（使用 JWT 的双方共享的自定义声明） 签名：签名是用于验证消息在传递过程中没有被篡改。它是通过头部中指定的签名算法，对编码后的头部和编码后的负载进行签名计算得到的 JWT 登录鉴权 # 用户输入账号密码信息 服务器验证信息是否正确，返回已签名token（JWT） 将token存储在客户端（local storage）/ cookie 在之后的HTTP请求中将token添加到请求头（一般为Authorazation） 服务器解码JWT，有效则接受请求。 ","date":"2025-01-19","externalUrl":null,"permalink":"/notes/engineer/","section":"Notes","summary":"记录 整理遇到的八股文知识点之 工程化篇","title":"八股文 -- 工程化","type":"notes"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/series/%E5%85%AB%E8%82%A1%E6%96%87-%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/","section":"Series","summary":"","title":"八股文 查缺补漏","type":"series"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/tags/docker/","section":"Tags","summary":"","title":"Docker","type":"tags"},{"content":" 安装nginx # \u0026ndash; docker pull nginx\n","date":"2025-01-19","externalUrl":null,"permalink":"/hugo/config/","section":"Hugoes","summary":"docker 部署 静态网站之","title":"docker 运行配置 nginx","type":"hugo"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/tags/http/","section":"Tags","summary":"","title":"Http","type":"tags"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/hugo/","section":"Hugoes","summary":"","title":"Hugoes","type":"hugo"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/tags/javascript/","section":"Tags","summary":"","title":"Javascript","type":"tags"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/tags/nginx/","section":"Tags","summary":"","title":"Nginx","type":"tags"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/tags/notes/","section":"Tags","summary":"","title":"Notes","type":"tags"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" url uri urn # URI 语法：scheme:[//[user:password@]host[:port]][/]path[?query][#fragment] Scheme：URI 的起始点，并与 URI 协议相关。URI schema 对大小写不敏感，后面带有一个“:”。几个流行的 URI schema 的例子：HTTP、HTTPS、FTP 和 mailto。 Authority（权限）：Authority 字段是位于 schema 字段之后的第二个条目，以两个斜杠(//)开头。这个字段由多个子字段组成： • authentication（认证信息）-可选的字段和用户名，密码，由冒号隔开，后面跟着“@”符号 • host（主机名）—注册的名称或 IP 地址，出现在“@”符号之后 • port（端口号）-可选字段，后面跟着一个冒号 Path（路径）：Path 是第三个字段，由斜杠分隔的段序列来表示，用来提供资源的位置。注意，不管 authority 部分存在或不存在，path 都应该以一个斜杠开始，而不是双斜杠(//)。 Query（查询）：Query 是第四个字段，是 URI 的可选字段，包含一串非结构数据并以“?”和 Path 隔开。 Fragment（片段）：Fragment 是第五个组成部分，也是一个可选字段，提供指向辅助资源的方向，并以“#”开始。简单来说，Fragment 字段可以用于指向 HTML 页面的特定元素(主资源)。\nurl（统一资源定位符），用于标示网络资源的位置。URL 是一个给定唯一 Web 资源的地址，表明了这个唯一的 Web 资源的位置，用户可以通过 URL 浏览互联网。如果我们在任何应用程序中点击任何超链接，它会将我们重定向到相关的 URL，这些 URL 也可以很容易的输入到浏览器地址栏中，并可以加载特定的资源。\nURN 是一种具有静态名称的互联网资源，即使它的数据被移动到另一个位置也仍然有效。URL 在内容被移动后就失效了，与之不同的是，URN 可以始终跟踪 Web 上某些数据的资源，从而解决了频繁移动数据的问题。 URN 语法：scheme:NID: NSS\nhttp https # http 1.0 # 无状态、无连接的应用层协议，一次只能发出一个未完成的请求\nhttp1.1 # \u0026ndash; 基于 connection：keep-alive 建立持久链接， \u0026ndash; 基于管道可以一次发出多个请求，但服务端依旧需要按顺序响应。 \u0026ndash; 新增 身份认证、缓存等机制相关的请求头。 \u0026ndash; HTTP1.1 的请求消息和响应消息都应支持 Host 头域\nhttp2.0 # \u0026ndash; 采用二进制消息帧，建立请求优先级 帧(frame)包含部分：类型 Type, 长度 Length, 标记 Flags, 流标识 Stream 和 frame payload 有效载荷 消息(message)：一个完整的请求或者响应，比如请求、响应等，由一个或多个 Frame 组成。\n\u0026ndash; 多路复用 请求响应都采用流式数据在同一个 tcp 通道内传输，通过 流标识 进行同一个 请求响应 的匹配。 \u0026ndash; 头部压缩 http2.0 头部也采用二进制数据格式，利用 HPACK 压缩算法（维护一张 header 字段表，利用索引代替实际 header） \u0026ndash; 服务器推送 服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确地请求\nhttp3.0 # \u0026ndash; 采用 QUIC 协议（基于 UDP） 解决了 TCP 协议 头包丢失导致的阻塞问题\nhttp 缓存 # 强缓存：浏览器会检测缓存时间是否过期，若未过期则不会向服务器发请求转而直接从缓存中读取。 在 http1.1 后改由请求头 cache-control 中的 max-age 控制。 命中强缓存 状态码返回 200 size 为 form disk cache / memory cache。\n协商缓存：浏览器优先检测是否命中强缓存，若未命中强缓存则浏览器携带协商缓存标识向服务器发起请求，由服务器根据缓存标识确定是否使用缓存，若生效则返回状态码 304，否则正常返回 200 和请求资源。 缓存是否失效 由 Last-Modified / If-Modified-Since 和 ETag 决定。 浏览器首次请求资源时服务器会在响应头中给到 Last-Modified ，浏览器再次请求该资源时 会在请求头中添加 If-Modified-Since 由服务器判断缓存资源是否失效。 由于 Last-Modified 只能精确到秒级，可能会导致已失效缓存被误判，且如果本地打开缓存文件也会更新 Last-Modified 。因此 Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag 就会重新生成。\najax fetch # ajax # const xhr = new XMLHttpRequest(); // 创建 xhr 操作对象 readyState = 0 xhr.open(\u0026#34;get\u0026#34;, \u0026#34;http://jsonplaceholder.typicode.com/posts/2\u0026#34;); // 建立请求 readyState = 1 xhr.setRequestHeader(\u0026#34;name\u0026#34;, \u0026#34;123\u0026#34;); xhr.send(/\\*_ 请求体可以放这里 _/); // 发送请求 readyState = 2 xhr.onreadystatechange = () =\u0026gt; { // readyState = 3 说明正在接收服务器传来的 body 部分的数据 if (xhr.readyState === 4 \u0026amp;\u0026amp; xhr.status === 200) { // readyState = 4 说明数据完全接收 console.log(xhr.response); } }; xhr.onprogress = (p) =\u0026gt; { if (p.lengthComputable) { // 表示底层流程将需要完成的总工作量和已经完成的工作量是否可以计算 console.log(p.total); // 表示正在执行的底层流程的工作总量 console.log(p.loaded); // 表示底层流程已经执行的工作总量 } }; fetch # \u0026ndash; 请求实例\nfetch(\u0026#34;http://jsonplaceholder.typicode.com/posts\u0026#34;, { //请求方法 method: \u0026#34;POST\u0026#34;, //请求头 headers: { name: \u0026#34;zhang\u0026#34; }, //请求体 body: JSON.stringify({ id: 1 }) }) .then((response) =\u0026gt; { return response.json(); }) .then((response) =\u0026gt; { console.log(response); }); \u0026ndash; 中断请求：\nconst controller = new AbortController(); const { signal } = controller; fetch(\u0026#34;http://\u0026#34;, { signal }); controller.abort(); 区别 # \u0026ndash; fetch 使用 promise、 XMLHttpRequest 则使用回调的方式(需要开发手动包装 promise) \u0026ndash; fetch 只有在中断请求或网络故障或配置错误时才会被标记 reject，其他时候都是 resolve；XHR 则需要在 onReadyStateChange 回调里自行判断 \u0026ndash; XHR 拥有 onProgress 回调监控传输进度 \u0026ndash; fetch 将请求分成了多个模型（Request、Responce、Headers）; XMLHttpRequest 只有一个自己的实例。 \u0026ndash; fetch 通过数据流处理数据，可以分块读取；XMLHTTPRequest 对象不支持数据流，所有的数据必须放在缓存里，不支持分块读取，必须等待全部拿到后，再一次性吐出来\n跨域 # 什么是跨域： 请求 url 的协议 域名 端口 中任意一个与当前页面 url 不同即为跨域 原因： 浏览器的同源策略规定非同源请求不能被浏览器所接受以防止 xss csrf 攻击\n解决方案：\n跨域资源共享（CORS） # \u0026ndash; 简单请求 浏览器会自动带上 Origin 请求头 服务器端验证 Origin 在白名单内则返回时添加 Access-Control-Allow-Origin 响应头告诉浏览器 允许该 Origin 访问 简单请求判断标准： a. 请求方法为 GET、POST、HEAD b. 请求头只允许出现 CORS 安全规范定义的标头集合 c. 请求中没有使用 ReadableStream 对象\n\u0026ndash; 非简单请求则需要在正式发起请求前进行 OPTIONS 预请求，该请求携带 Origin、Access-Control-Request-Method、Access-Control-Request-Headers 等请求头以便服务器验证是否允许实际请求。\n代理服务器 # JSONP \u0026amp; window.name # Web 安全 # XSS（跨站脚本攻击） 原理： 向目标网站注入脚本以获取用户信息等。 分类： 存储型（向服务器发送攻击脚本，存储在服务器中，用户正常请求时受到攻击），反射型（恶意链接），基于 DOM 防御： 浏览器/服务器端做好特殊字符转换校验，重要 cookie 可设置 httpOnly 属性防止被窃取。利用 csp 禁止除安全脚本以外的脚本运行。\nCSRF(跨站请求伪造) 原理：诱导用户打开三方网站，利用用户的登录态发起跨站请求。 分类： 自动发起 Get 请求(利用 img 等 src 属性)\n\u0026lt;img src=\u0026#34;https://time.geekbang.org/sendcoin?user=hacker\u0026amp;number=100\u0026#34; /\u0026gt; 自动发起 Post 请求（利用隐藏表单自动提交 ）\n\u0026lt;script\u0026gt; document.getElementById (\u0026#39;hacker-form\u0026#39;).submit();\u0026lt;/script\u0026gt; 不良链接\n\u0026lt;img width=150 src=http://images.xuejuzi.cn/1612/1-161230185104_1.jpg\u0026gt;\u0026lt;/img\u0026gt; \u0026lt;a href=\u0026#34;https://time.geekbang.org/sendcoin?user=hacker\u0026amp;number=100\u0026#34; taget=\u0026#34;\\_bla 点击下载美女照片\u0026#34; 防御： 通过设置 Access-Control-Allow-Origin 不允许或只允许安全域名下发起请求 利用 cookie 的 SameSite 属性 禁止三方请求发送重要 cookie。 利用 token 验证是否为合法三方请求。\nCSP # 定义：CSP 是一种用于增强网站安全的策略，他通过限制网页内容的来源和执行的方式来减少恶意攻击。\n原理： · 服务器设置策略：服务器端通过相应头 content-security-policy / content-security-policy-report-only 来设置 CSP 策略。 · 浏览器执行策略：浏览器加载网页时，会根据服务器端返回的 csp 策略限制网页中各种资源的加载和执行，并阻止不符合策略的操作。 · 检查资源来源：浏览器会检查网页中所有资源的来源是否符合 CSP 策略中定义的规则，如果资源的来源于策略不匹配，浏览器组织加载该资源。 · 限制脚本执行：CSP 还可以通过禁止或限制内连脚本的执行来阻止 XSS 攻击。\n","date":"2025-01-19","externalUrl":null,"permalink":"/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","section":"Notes","summary":"记录 整理遇到的八股文知识点之 计算机网络篇","title":"八股文 -- 计算机网络","type":"notes"},{"content":" ES6 新特性 # 块级作用域 let const 无变量提升 const 创建变量不可更改 箭头函数 解构赋值与扩展运算符 // 解构赋值 const { name, age } = obj; // 扩展运算符 const a = [...arr]; const b = { ...obj }; promise 与 生成器函数 proxy ps:Object.defineProperty 比较 \u0026ndash; df 只能单独定义某个属性，要代理整个对象需要遍历对象，分别代理，数组也是如此；proxy 可以代直接理整个对象。 \u0026ndash; df 在原对象上处理，proxy 则新创建代理对象在代理对象上进行处理 \u0026ndash; proxy 实质创建了一个异质对象，在异质对象中的所有操作\nObject.defineProperty(obj, prop, descriptor); const proxy = new Proxy(target, handler); 新基础数据类型 Symbol、BigInit 新的数据结构 Map、Set new 关键字 # . 创建一个空对象 . 将新对象的proto 赋值为构造函数的 prototype . 将构造函数中的 this 指向该对象 . 执行构造函数，如果构造函数返回引用数据类型 则直接返回该对象，否则返回新对象。\nfunction Person(name: any) { this.name = name; return { name }; } function Person2(name: any) { this.name = name; } Person.prototype = { sayHello() { console.log(\u0026#34;hello\u0026#34;); } }; const person = new Person(\u0026#34;aa\u0026#34;); const person2 = new Person2(\u0026#34;bb\u0026#34;); // Person 返回了引用类型 new 直接将引用类型返回 即 person 是用字面量形式创建的对象,其构造函数为Object console.log(person.__proto__ === Object.prototype); // true // Person2 没有返回值，new 将创建的新对象返回，该对象的__proto__ 指向构造函数Person2的prototype console.log(person2.__proto__ === Person2.prototype); // true console.log(person.constructor === Object); // true js 类型判断 # instanceOf # 语法：obj instanceof Type 功能：判断 obj 是不是 Type 类的实例，只可用来判断引用数据 实现思路： Type 的原型对象是否是 obj 的原型链上的某个对象\nFunction.prototype.myInstanceOf = function (fuc: Function) { let proto = (this as Object).__proto__; const pt = fuc.prototype; while (proto) { if (pt === proto) return true; proto = proto.__proto__; } return false; }; Object.prototype.toString # function typeOf(data) { return Object.prototype.toString.call(data).slice(8, -1); } js brage # native -\u0026gt; h5: 向 webview 注入 js 脚本执行 h5 -\u0026gt; native:\nwebview 劫持请求通信 协议格式： :///?#fragment eg：jsbridge://showToast?text=hello\n通过 webview 提供的接口，app 将 Native 相关方法注入到 JS 的全局对象中。\n深拷贝 处理循环依赖 # WeakMap 缓存引用类型，每次引用类型拷贝时先判断是否存在缓存，有则直接用，无则缓存下来。\nWeakMap 键值必须为引用对象或 Symbol\n转 JSON 进行深拷贝弊端 # \u0026ndash; Date 类型会被转为字符串 \u0026ndash; RegExp、Map 、Set 类型会被转为 空对象， \u0026ndash; 拷贝 function 或遇到循环引用时 会报错 \u0026ndash; 对象属性值为 function、undefind、时 会丢失 \u0026ndash; 对象中有 NaN、Infinity 和-Infinity 的时候，序列化之后会显示 null。\n生成器函数 (手动实现一个 async/await) # // 生成器函数 export function* _async() { const userInfo: number = yield getUserInfo(); console.log(\u0026#34;2222\u0026#34;, userInfo); const name: string = yield () =\u0026gt; { return \u0026#34;dengxi\u0026#34;; }; console.log(\u0026#34;name\u0026#34;, name); const num: number = yield 3; console.log(\u0026#34;num\u0026#34;, num); } export const autoRun = (generator: () =\u0026gt; Generator\u0026lt;any\u0026gt;) =\u0026gt; { const gen = generator(); const next = (data: any) =\u0026gt; { const result = gen.next(data); if (result.done) return; if (result.value instanceof Promise) { result.value.then((res: any) =\u0026gt; { next(res); }); } else if (typeof result.value === \u0026#34;function\u0026#34;) { next(result.value()); } else { next(result.value); } }; next(undefined); }; autoRun(_async); for 循环 forEach 循环 区别 # for 循环： js 自身语法，性能更优，可通过 continue 关键字单次中断，break 关键字 中断整个循环。 forEach 循环：本质是可迭代对象原型方法，执行时会开辟执行栈，因此性能上略逊 for，不可中断，且只能遍历实现了迭代器属性的对象。\n在内部执行 async 方法 有什么区别\nfor 循环内部执行 async 方法时 会等待 await 执行完成后再执行下一次循环。 forEach 循环内部执行 async 方法时 会直接同步执行所有循环后再等待 await 语句执行完成。\nforEach 可以中断么？ 不可自己中断，可通过抛出异常中断\nPromise # 定义: 一个对象有 then 方法且该方法返回一个 promise,有一个状态属性初始为 pending，可转化为 fulfilled 或 rejected 且转化不可逆。（Promise A+ 中定义）\npromise 实例方法： then 、catch、finally promise 原型方法：all、allSettled、race、any、resolve、reject\n\u0026ndash; race：接收一个 promise 数组，返回首个状态变更 的 promise。 \u0026ndash; any：接收一个 promise 数组，返回首个状态变更为 resolve 的 Promise 实例。 \u0026ndash; resolve：接收任意参数，返回一个 fulfilled 状态的 promise 实例，resolve 参数为给定参数 \u0026ndash; reject： 接收任意参数，返回一个带有拒绝原因的 Promise 实例。\nPromise.all # 接收一个 promise 数组，返回一个 promise，当 promise 数组都成功时，该 promise 变更为 fulfield，若有 promise 失败，则该 promise 也失败并返回第一个失败的原因。\nconst p1 = new Promise((res, rej) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;11111111\u0026#34;); res(\u0026#34;promise1 成功返回！\u0026#34;); }, 1000); }); const p2 = new Promise((res, rej) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;22222222\u0026#34;); res(\u0026#34;promise2 成功返回！\u0026#34;); }, 2000); }); const p3 = new Promise((res, rej) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(\u0026#34;3333333\u0026#34;); res(\u0026#34;promise3 reject！\u0026#34;); }, 3000); }); const arr = [p1, p2, p3]; const myPromiseAll = (array: Promise\u0026lt;any\u0026gt;[]) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { let count = 0, resList = new Array(array.length); array.forEach((item, index) =\u0026gt; { item.then( (res) =\u0026gt; { resList[index] = res; count++; if (count === array.length) resolve(resList); }, (err) =\u0026gt; reject(err) ); }); }); }; const myPromiseAllByAwait = (array: Promise\u0026lt;any\u0026gt;[]) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { let count = 0, resList = new Array(array.length); try { array.forEach(async (item, index) =\u0026gt; { const res = await item; resList[index] = res; count++; if (count === array.length) resolve(resList); }); } catch (error) { reject(error); } }); }; mapPromiseAll(arr).then( (res) =\u0026gt; { console.log(\u0026#34;res\u0026#34;, res); }, (rej) =\u0026gt; console.log(\u0026#34;rej\u0026#34;, rej) ); Promise.allSettled # 接收一个 promise 数组，返回一个 promise。当数组中所有 promise 状态都变更后，该 promise 才会变更为 resolve，resolve 参数为该 promise 数组\nconst myPromiseAllSettled = (promises: Promise\u0026lt;any\u0026gt;[]) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { let count = 0, resArray = new Array(promises.length); promises.forEach((item, idx) =\u0026gt; { item .then( (res) =\u0026gt; { resArray[idx] = { status: \u0026#34;fulfilled\u0026#34;, value: res }; }, (rej) =\u0026gt; { resArray[idx] = { status: \u0026#34;rejected\u0026#34;, reason: rej }; } ) .finally(() =\u0026gt; { count++; if (count === promises.length) return resolve(resArray); }); }); }); }; Promise.retry # const retry = (callback: () =\u0026gt; Promise\u0026lt;any\u0026gt;, retryTime = 5) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { callback().then( () =\u0026gt; { resolve(retryTime); }, (reason: any) =\u0026gt; { if (!retryTime) reject(reason); else { retry(callback, --retryTime).then(resolve, reject); } } ); }); }; function getProm() { const n = Math.random(); return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; (n \u0026gt; 1 ? resolve(n) : reject(n)), 100); }); } retry(getProm, 4) .then((res) =\u0026gt; console.log(\u0026#34;res\u0026#34;, res)) .catch((err) =\u0026gt; console.log(\u0026#34;err\u0026#34;, err)); async await # async 函数返回的是一个 Promise 对象 await 返回的是当前语句的执行结果\n若当前语句返回一个 promise，则 await 会阻塞后续代码执行 等待当前 promise 状态变更为 resolve，然后得到 resolve 的值作为 await 表达式的运算结果 当前语句返回的不是一个 promise，await 表达式直接将该值作为运算结果。 怎么做到同步执行的 # 只是相对于 当前 async 函数内 后续语句同步 将后续语句包装成异步回调\ncanvas / 图片 相互转化 # 图片转 canvas： 将图片绘制在 canvas 上( drawImage() ),该方法接受三个参数：要绘制的图像、起始点的 x 坐标和 y 坐标。 eg:\nvar canvas = document.getElementById(\u0026#34;myCanvas\u0026#34;); var ctx = canvas.getContext(\u0026#34;2d\u0026#34;); var img = new Image(); img.onload = function () { ctx.drawImage(img, 0, 0); }; img.src = \u0026#34;image.jpg\u0026#34;; canvas 转图片：调用 toDataURL()方法将 Canvas 转换为图片的数据 URL。可以将数据 URL 赋值给一个标签的 src 属性，或者使用它进行其他操作，如下载图片。 eg:\nvar canvas = document.getElementById(\u0026#34;myCanvas\u0026#34;); var dataURL = canvas.toDataURL(\u0026#34;image/png\u0026#34;); apply call bind # fn.apply(thisObj, [1, 2, 3]); fn.call(thisObj, 1, 2, 3); const a = fn.bind(thisObj, 1, 2, 3); a(); ","date":"2025-01-19","externalUrl":null,"permalink":"/notes/js/","section":"Notes","summary":"记录 整理遇到的八股文知识点之 js篇","title":"八股文 -- JS","type":"notes"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/series/react18-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","section":"Series","summary":"","title":"React18 阅读笔记","type":"series"},{"content":" 配置好的仓库自取(带阅读笔记版): react-debug github link vite # 创建项目 # pnpm create vite # (根据提示配置项目) ... 下载 react 源码 # github 地址：https://github.com/facebook/react 切换 tag ，找到对应版本 本文是 18.2.0 版本\n# 切换目录到src下，直接clone整个react资源包 cd src git clone git@github.com:facebook/react.git 配置 vite.config.js # import { defineConfig } from \u0026#34;vite\u0026#34;; import react from \u0026#34;@vitejs/plugin-react\u0026#34;; import path from \u0026#34;path\u0026#34;; // https://vitejs.dev/config/ export default defineConfig({ plugins: [react()], resolve: { // 配置别名 alias: { react: path.posix.resolve(\u0026#34;src/react/packages/react\u0026#34;), \u0026#34;react-dom\u0026#34;: path.posix.resolve(\u0026#34;src/react/packages/react-dom\u0026#34;), \u0026#34;react-dom-bindings\u0026#34;: path.posix.resolve( \u0026#34;src/react/packages/react-dom-bindings\u0026#34; ), \u0026#34;react-reconciler\u0026#34;: path.posix.resolve( \u0026#34;src/react/packages/react-reconciler\u0026#34; ), \u0026#34;react-client\u0026#34;: path.posix.resolve(\u0026#34;src/react/packages/react-client\u0026#34;), scheduler: path.posix.resolve(\u0026#34;src/react/packages/scheduler\u0026#34;), shared: path.posix.resolve(\u0026#34;src/react/packages/shared\u0026#34;) } }, // 配置环境变量 define: { __DEV__: false, __EXPERIMENTAL__: true, __PROFILE__: true } }); 由于 DEV 配置的 false，需要手动改赋值一下 jsxDEV\n// path: src/react/packages/react/src/jsx/ReactJSX.js // 注释掉原来的 赋值 直接赋值为 _jsxDEV(之前赋值为 jsxProd 会报错 没解决掉) // const jsxDEV = __DEV__ ? _jsxDEV : undefined; const jsxDEV = _jsxDEV; 配置 tsconfig.json / jsconfig.json # // ... \u0026#34;compilerOptions\u0026#34;: { \u0026#34;baseUrl\u0026#34;: \u0026#34;./\u0026#34;, \u0026#34;paths\u0026#34;: { \u0026#34;react/*\u0026#34;: [ \u0026#34;src/react/packages/react/*\u0026#34; ], \u0026#34;react-dom/*\u0026#34;: [ \u0026#34;src/react/packages/react-dom/*\u0026#34; ], \u0026#34;react-dom-bindings/*\u0026#34;: [ \u0026#34;src/react/packages/react-dom-bindings/*\u0026#34; ], \u0026#34;react-reconciler/*\u0026#34;: [ \u0026#34;src/react/packages/react-reconciler/*\u0026#34; ], \u0026#34;scheduler/*\u0026#34;: [ \u0026#34;src/react/packages/scheduler/*\u0026#34; ], \u0026#34;shared/*\u0026#34;: [ \u0026#34;src/react/packages/shared/*\u0026#34; ] } }, // ... vscode 调试 # 初始化launch.js # 回退到项目根目录 cd .. # 安装依赖 pnpm i # 起项目 pnpm dev F5 启动调试\n解决报错 # 参考:\nReact 18 debugger 源码分析配置\nwebpack # 创建项目 # npx create-react-app debug-react # 暴露webpack 配置 npm run eject 下载 react 源码 # github 地址：https://github.com/facebook/react 切换 tag ，找到对应版本 本文是 18.2.0 版本\n# 切换目录到src下，直接clone整个react资源包 cd src git clone git@github.com:facebook/react.git 修改配置 # // config/webpack.config.js \u0026#39;react\u0026#39;: path.resolve(__dirname, \u0026#39;../src/react/packages/react\u0026#39;), \u0026#39;react-dom\u0026#39;: path.resolve(__dirname, \u0026#39;../src/reactpackages/react-dom\u0026#39;), \u0026#39;react-dom-bindings\u0026#39;: path.resolve(__dirname, \u0026#39;../srcreact/packages/react-dom-bindings\u0026#39;), \u0026#39;react-reconciler\u0026#39;: path.resolve(__dirname, \u0026#39;../srcreact/packages/react-reconciler\u0026#39;), \u0026#39;shared\u0026#39;: path.resolve(__dirname, \u0026#39;../src/react/packagesshared\u0026#39;), \u0026#39;scheduler\u0026#39;: path.resolve(__dirname, \u0026#39;../src/reactpackages/scheduler\u0026#39;), webpack 配置 alias // /config/env.js __DEV__: true, __PROFILE__: true, __UMD__: true, __EXPERIMENTAL__: true, __VARIANT__: true, 全局变量 解决报错 # 参考\n手把手教你配置 React18 调试环境\n","date":"2025-01-19","externalUrl":null,"permalink":"/react/debug/","section":"Reacts","summary":"简述如何利用打包工具 webpack / vite 配置 react debug 环境","title":"React18 阅读笔记 -- debug 环境搭建","type":"react"},{"content":"","date":"2025-01-19","externalUrl":null,"permalink":"/react/","section":"Reacts","summary":"","title":"Reacts","type":"react"},{"content":"","date":"2025-01-18","externalUrl":null,"permalink":"/tags/react/","section":"Tags","summary":"","title":"React","type":"tags"},{"content":" 入口 # function beginWork( current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes ): Fiber | null { // ...省略，这里只关注 switch case 部分 // 这里列举全部 case，下面会对部分case进行梳理 switch (workInProgress.tag) { // 挂载时, 此时的 function class 组件还未区分，都走该case case IndeterminateComponent: { return mountIndeterminateComponent( current, workInProgress, workInProgress.type, renderLanes ); } case LazyComponent: { const elementType = workInProgress.elementType; return mountLazyComponent( current, workInProgress, elementType, renderLanes ); } case FunctionComponent: { const Component = workInProgress.type; const unresolvedProps = workInProgress.pendingProps; const resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps); return updateFunctionComponent( current, workInProgress, Component, resolvedProps, renderLanes ); } case ClassComponent: { const Component = workInProgress.type; const unresolvedProps = workInProgress.pendingProps; const resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps); return updateClassComponent( current, workInProgress, Component, resolvedProps, renderLanes ); } // 在 create 中 已梳理 case HostRoot: return updateHostRoot(current, workInProgress, renderLanes); case HostComponent: return updateHostComponent(current, workInProgress, renderLanes); case SuspenseComponent: return updateSuspenseComponent(current, workInProgress, renderLanes); case HostPortal: return updatePortalComponent(current, workInProgress, renderLanes); case ForwardRef: { const type = workInProgress.type; const unresolvedProps = workInProgress.pendingProps; const resolvedProps = workInProgress.elementType === type ? unresolvedProps : resolveDefaultProps(type, unresolvedProps); return updateForwardRef( current, workInProgress, type, resolvedProps, renderLanes ); } case Mode: return updateMode(current, workInProgress, renderLanes); case Profiler: return updateProfiler(current, workInProgress, renderLanes); case ContextProvider: return updateContextProvider(current, workInProgress, renderLanes); case ContextConsumer: return updateContextConsumer(current, workInProgress, renderLanes); case MemoComponent: { const type = workInProgress.type; const unresolvedProps = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props. let resolvedProps = resolveDefaultProps(type, unresolvedProps); resolvedProps = resolveDefaultProps(type.type, resolvedProps); return updateMemoComponent( current, workInProgress, type, resolvedProps, renderLanes ); } // ...省略部分 case } } case 梳理 # 在梳理具体 case 之前，将简单介绍部分 公共方法\nexport function prepareToReadContext( workInProgress: Fiber, renderLanes: Lanes ): void { currentlyRenderingFiber = workInProgress; lastContextDependency = null; lastFullyObservedContext = null; const dependencies = workInProgress.dependencies; if (dependencies !== null) { const firstContext = dependencies.firstContext; if (firstContext !== null) { if (includesSomeLane(dependencies.lanes, renderLanes)) { //将 ReactFiberBeginWork 中的 局部属性 didReceiveUpdate 值更改为 true; markWorkInProgressReceivedUpdate(); } dependencies.firstContext = null; } } } IndeterminateComponent # 函数组件 \u0026amp; 类组件 首次挂载时都会走到该 case 会先执行 renderWithHooks 方法 后 判断 value 是否有 render 方法 来确认是 函数组件 or 类组件 并给 fiber 打标。函数组件 类组件 具体实现 在对应 case 中梳理\nfunction mountIndeterminateComponent( _current, workInProgress, Component, renderLanes ) { const props = workInProgress.pendingProps; let context; prepareToReadContext(workInProgress, renderLanes); value = renderWithHooks( null, workInProgress, Component, props, context, renderLanes ); if ( typeof value === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; value !== null \u0026amp;\u0026amp; typeof value.render === \u0026#34;function\u0026#34; \u0026amp;\u0026amp; value.$$typeof === undefined ) { workInProgress.tag = ClassComponent; // TODO 类组件挂载时 具体实现流程梳理 } else { workInProgress.tag = FunctionComponent; // 将子节点 reconcileChildren(null, workInProgress, value, renderLanes); return workInProgress.child; } } FunctionComponent # function updateFunctionComponent( current, workInProgress, Component, nextProps: any, renderLanes ) { // ... let context, nextChildren, hasId; prepareToReadContext(workInProgress, renderLanes); nextChildren = renderWithHooks( current, workInProgress, Component, nextProps, context, renderLanes ); // ...省略部分代码 只关注 主要步骤 // React DevTools reads this flag. workInProgress.flags |= PerformedWork; reconcileChildren(current, workInProgress, nextChildren, renderLanes); return workInProgress.child; } renderWithHooks # export function renderWithHooks\u0026lt;Props, SecondArg\u0026gt;( current: Fiber | null, workInProgress: Fiber, Component: (p: Props, arg: SecondArg) =\u0026gt; any, props: Props, secondArg: SecondArg, nextRenderLanes: Lanes ): any { // 将 HooksDispatcher 切换为 update ReactCurrentDispatcher.current = current === null || current.memoizedState === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate; // 这里的 Component 则为具体的 函数组件 let children = Component(props, secondArg); return children; } LazyComponent # function mountLazyComponent( _current, workInProgress, elementType, renderLanes ) { const props = workInProgress.pendingProps; const lazyComponent: LazyComponentType\u0026lt;any, any\u0026gt; = elementType; const payload = lazyComponent._payload; const init = lazyComponent._init; let Component = init(payload); workInProgress.type = Component; const resolvedTag = (workInProgress.tag = resolveLazyComponentTag(Component)); const resolvedProps = resolveDefaultProps(Component, props); let child; switch (resolvedTag) { case FunctionComponent: { // 具体流程在对应case中梳理 } case ClassComponent: { // ... } // ... } } // 该方法会在 renderWidthHook 中执行,后在 遍历到 lazy 组件时 执行 init 初始化组件 // 后续更新 则走 对应分支 export function lazy\u0026lt;T\u0026gt;( ctor: () =\u0026gt; Thenable\u0026lt;{default: T, ...}\u0026gt;, ): LazyComponent\u0026lt;T, Payload\u0026lt;T\u0026gt;\u0026gt; { const payload: Payload\u0026lt;T\u0026gt; = { // We use these fields to store the result. _status: Uninitialized, _result: ctor, }; const lazyType: LazyComponent\u0026lt;T, Payload\u0026lt;T\u0026gt;\u0026gt; = { $$typeof: REACT_LAZY_TYPE, _payload: payload, _init: lazyInitializer, }; return lazyType; } function lazyInitializer\u0026lt;T\u0026gt;(payload: Payload\u0026lt;T\u0026gt;): T { if (payload._status === Uninitialized) { const ctor = payload._result; // 执行异步加载方法 （一般是 import()） const thenable = ctor(); thenable.then( moduleObject =\u0026gt; { // 同步 lazy 组件 的状态与加载结果 if (payload._status === Pending || payload._status === Uninitialized) { // Transition to the next state. payload._status = Resolved; payload._result = moduleObject; } }, error =\u0026gt; { if (payload._status === Pending || payload._status === Uninitialized) { // Transition to the next state. payload._status = Rejected; payload._result = error; } }, ); if (payload._status === Uninitialized) { // 首次进来时改为 Pending 状态 const pending: PendingPayload = (payload: any); pending._status = Pending; pending._result = thenable; } } if (payload._status === Resolved) { // 如果 promise 完成了，那么会将加载的模块返回 const moduleObject = payload._result; return moduleObject.default; } else { // 第一次加载时，报错 throw payload._result; } } HostComponent # const isDirectTextChild = shouldSetTextContent(type, nextProps); // \u0026hellip; reconcileChildren(current, workInProgress, nextChildren, renderLanes);\nSuspenseComponent # TODO 后续补充\nHostPortal # function updatePortalComponent( current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes ) { // 在它的子节点被添加时，可以找到这个containerInfo节点。 // 这样就可以达到fiber在rootFiber内，但是添加的真实节点在其他节点的目的 pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo); const nextChildren = workInProgress.pendingProps; reconcileChildren(current, workInProgress, nextChildren, renderLanes); return workInProgress.child; } export function createPortal( children: ReactNodeList, containerInfo: any, implementation: any, key: ?string = null ): ReactPortal { return { $$typeof: REACT_PORTAL_TYPE, key: key == null ? null : \u0026#34;\u0026#34; + key, children, containerInfo, implementation }; } export function createFiberFromPortal( portal: ReactPortal, mode: TypeOfMode, lanes: Lanes ): Fiber { const pendingProps = portal.children !== null ? portal.children : []; const fiber = createFiber(HostPortal, pendingProps, portal.key, mode); fiber.lanes = lanes; fiber.stateNode = { containerInfo: portal.containerInfo, pendingChildren: null, // Used by persistent updates implementation: portal.implementation }; return fiber; } # ","date":"2025-01-18","externalUrl":null,"permalink":"/react/beginwork_case/","section":"Reacts","summary":"聚焦 beginwork 中针对 不同的 tag 具体实现逻辑","title":"React18 阅读笔记 -- BeginWork case 梳理","type":"react"},{"content":" completeWork # 根据 workInProgress.tag 找到需要创建/更新 dom 的 tag，根据 fiber 创建/更新 dom\n// path: packages/react-reconciler/src/ReactFiberCompleteWork.old.js function completeWork( current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes ): Fiber | null { switch (workInProgress.tag) { case IndeterminateComponent: case LazyComponent: case SimpleMemoComponent: case FunctionComponent: case ForwardRef: case Fragment: case Mode: case Profiler: case ContextConsumer: case MemoComponent: bubbleProperties(workInProgress); return null; case HostText: { // ...省略部分代码 // 根据不同tag 为 stateNode 创建 对应dom 节点 workInProgress.stateNode = createTextInstance( newText, rootContainerInstance, // root currentHostContext, workInProgress ); // 将所有child 的 return赋值为 completedWork； // 计算 completedWork 的 subtreeFlags bubbleProperties(workInProgress); return null; } case HostComponent: { // 将当前 fiber 移出 fiberStack popHostContext(workInProgress); // 在beginWork中对于HostRoot和HostPortal节点都会将真实节点container全 // 局存储到rootInstanceStackCursor.current，而在completeWork阶段将其移出。 // 在访问子节点时就能正确获取到它所在的容器 // 获取的是当前的 RootHostContainer const rootContainerInstance = getRootHostContainer(); const type = workInProgress.type; if (current !== null \u0026amp;\u0026amp; workInProgress.stateNode != null) { // // 如果真实节点存在，那么进行更新 updateHostComponent( current, workInProgress, type, newProps, rootContainerInstance ); } else { if (!newProps) { bubbleProperties(workInProgress); return null; } const currentHostContext = getHostContext(); const instance = createInstance( type, newProps, rootContainerInstance, currentHostContext, workInProgress ); // 将能渲染的子节点全部添加到当前创建的节点instance上 appendAllChildren(instance, workInProgress, false, false); workInProgress.stateNode = instance; } bubbleProperties(workInProgress); return null; } } } HostComponent # root 根节点 进如的 case\nexport function updateHostComponent() { // ... // 类似结构：[\u0026#39;name\u0026#39;, \u0026#39;张三\u0026#39;, \u0026#39;id\u0026#39;, 333, \u0026#39;style\u0026#39;, { color: \u0026#39;red\u0026#39; }] const updatePayload = prepareUpdate( instance, type, oldProps, newProps, rootContainerInstance, currentHostContext, ); workInProgress.updateQueue = (updatePayload: any); // 标记为 Update if (updatePayload) { markUpdate(workInProgress); } }; export function createInstance( type: string, props: Props, rootContainerInstance: Container, hostContext: HostContext, internalInstanceHandle: Object ): Instance { // 创建了 element const domElement: Instance = createElement( type, props, rootContainerInstance, parentNamespace ); // 建立关系 node . \u0026#39;__reactFiber$\u0026#39; + randomKey = fiber precacheFiberNode(internalInstanceHandle, domElement); // 建立关系 node . \u0026#39;__reactProps$\u0026#39; + randomKey = props updateFiberProps(domElement, props); return domElement; } ","date":"2025-01-18","externalUrl":null,"permalink":"/react/completework/","section":"Reacts","summary":"workloop 的 归 阶段， 根据已经创建/更新 好的 fiber 开始构建真实dom，TODO:有时间需要再梳理一下","title":"React18 阅读笔记 -- completeWork","type":"react"},{"content":" 入口 # // path: packages/react-reconciler/src/ReactFiberBeginWork.old.js beginWork = (current, unitOfWork, lanes) =\u0026gt; { didReceiveUpdate = false; workInProgress.lanes = NoLanes; // 一大堆switch case 单独放在下一个文件中整理 // 这里只处理了 unitOfWork 为 hostRoot 的case return updateHostRoot(current, workInProgress, renderLanes); }; function updateHostRoot(current, workInProgress, renderLanes) { pushHostRootContext(workInProgress); // 将 current 的 UpdateQueue 拷贝给 workInProgress cloneUpdateQueue(current, workInProgress); /** * 将当前将要进行的更新 shared.pending 的环形链表，拆开拼接到到 lastBaseUpdate 的后面； * 执行 firstBaseUpdate 链表的操作时，若当前 update 对应的任务的优先级符合要求，则执行； * 若优先级较低，则存储执行到当前节点的状态，做为下次渲染时的初始值，和接下来所有的 update 节点； * 将执行所有操作后得到的 newState 重新给到 workInProgress.memoizedState； * 然后存储刚才淘汰下来的低优先级任务的链表，以便下次更新； */ processUpdateQueue(workInProgress, nextProps, null, renderLanes); const nextState: RootState = workInProgress.memoizedState; const root: FiberRoot = workInProgress.stateNode; const nextChildren = nextState.element; reconcileChildren(current, workInProgress, nextChildren, renderLanes); return workInProgress.child; } reconcileChildren # // export const reconcileChildFibers = ChildReconciler(true); // export const mountChildFibers = ChildReconciler(false); // 该初始化参数b表示是否有 current ,未在 reconcileChildFibers 中使用 function reconcileChildren( current: Fiber | null, workInProgress: Fiber, nextChildren: any, renderLanes: Lanes ) { if (current === null) { // mountChildFibers 也就是初始化 ChildReconciler 后 执行 reconcileChildFibers workInProgress.child = mountChildFibers( workInProgress, null, nextChildren, renderLanes ); // 更新阶段 } else { workInProgress.child = reconcileChildFibers( workInProgress, current.child, nextChildren, renderLanes ); } } reconcileChildFibers # // path: packages/react-reconciler/src/ReactChildFiber.old.js // 根据 newChild.$$typeof 不同类型 创建 fiber function reconcileChildFibers( returnFiber: Fiber, currentFirstChild: Fiber | null, newChild: any, lanes: Lanes ): Fiber | null { if (typeof newChild === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; newChild !== null) { switch (newChild.$$typeof) { case REACT_ELEMENT_TYPE: // react.element return placeSingleChild( // 调用 createFiberFromElement 为child 创建 fiber reconcileSingleElement( returnFiber, currentFirstChild, newChild, lanes ) ); case REACT_LAZY_TYPE: // react.lazy const payload = newChild._payload; const init = newChild._init; // TODO: This function is supposed to be non-recursive. return reconcileChildFibers( returnFiber, currentFirstChild, // _init: lazyInitializer, 具体实现 放在 update 中梳理 init(payload), lanes ); case REACT_PORTAL_TYPE: // react.portal return placeSingleChild( reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes) ); } // child有多个 if (isArray(newChild)) { return reconcileChildrenArray( returnFiber, currentFirstChild, newChild, lanes ); } throwOnInvalidObjectType(returnFiber, newChild); } } REACT_ELEMENT_TYPE # 当类型为 react.element 时，会先调用 reconcileSingleElement 方法，校验 key 和 type 是否一致，如果一致则使用 useFiber 方法进行复用 fiber。然后 调用 placeSingleChild 根据 current 与 当前 finber.alternate 判断是否需要给 fiber.flages 标记为新增\nfunction reconcileSingleElement( returnFiber: Fiber, currentFirstChild: Fiber | null, element: ReactElement, lanes: Lanes ): Fiber { const key = element.key; let child = currentFirstChild; while (child !== null) { // key 一致 直接复用 if (child.key === key) { const elementType = element.type; if (elementType === REACT_FRAGMENT_TYPE) { if (child.tag === Fragment) { // 如果是 Fragment 标签 则跳过直接复用 Fragment 的 children deleteRemainingChildren(returnFiber, child.sibling); const existing = useFiber(child, element.props.children); existing.return = returnFiber; return existing; } } else { deleteRemainingChildren(returnFiber, child.sibling); const existing = useFiber(child, element.props); existing.ref = coerceRef(returnFiber, child, element); existing.return = returnFiber; return existing; } // Didn\u0026#39;t match. // 遍历所有子节点 将 child 加入 fiber.deletions 并将 renturnFiber.flags 标记为 ChildDeletion deleteRemainingChildren(returnFiber, child); break; } else { deleteChild(returnFiber, child); } child = child.sibling; } // 否则直接新建fiber if (element.type === REACT_FRAGMENT_TYPE) { const created = createFiberFromFragment( element.props.children, returnFiber.mode, lanes, element.key ); created.return = returnFiber; return created; } else { const created = createFiberFromElement(element, returnFiber.mode, lanes); created.ref = coerceRef(returnFiber, currentFirstChild, element); created.return = returnFiber; return created; } } function placeSingleChild(newFiber: Fiber): Fiber { if (shouldTrackSideEffects \u0026amp;\u0026amp; newFiber.alternate === null) { newFiber.flags |= Placement; } return newFiber; } REACT_LAZY_TYPE # reconcileChildrenArray # function reconcileChildrenArray( returnFiber: Fiber, currentFirstChild: Fiber | null, newChildren: Array\u0026lt;*\u0026gt;, lanes: Lanes ): Fiber | null { let resultingFirstChild: Fiber | null = null; let previousNewFiber: Fiber | null = null; // oldFiber 是老 fiber 的第一个 child，可以通过 sibling 进行遍历。 let oldFiber = currentFirstChild; // lastPlacedIndex 表示最后一个老fiber被复用的位置 let lastPlacedIndex = 0; // 表示新 ReactElement 的位置 let newIdx = 0; // 表示下一个老fiber let nextOldFiber = null; // Diff 算法，标记子节点中需要的操作，记录在 flags 中 // 这个位置相当于只对比了前面的一部分， // 如果出现 key 和 type 不一致的情况，那么会跳出对比。 for (; oldFiber !== null \u0026amp;\u0026amp; newIdx \u0026lt; newChildren.length; newIdx++) { if (oldFiber.index \u0026gt; newIdx) { // 一直找到 oldFiber index 与 newIdx 相等的节点 // 否则的话，oldFiber 不向后遍历。 nextOldFiber = oldFiber; oldFiber = null; } else { // 遍历下一个 fiber nextOldFiber = oldFiber.sibling; } // 这里的 newChildren 是 jsx 解析出来的 children，为 ReactElement节点 // 根据节点类型创建或者更新 fiber const newFiber = updateSlot( returnFiber, oldFiber, newChildren[newIdx], lanes ); if (newFiber === null) { // key 或 type 不相同时，不可复用。 // 此时 newFiber 为 null，对比就会终止。 // 这就意味着找到了第一个无法复用的节点 if (oldFiber === null) { oldFiber = nextOldFiber; } break; } // 更新时 需要标记 if (shouldTrackSideEffects) { if (oldFiber \u0026amp;\u0026amp; newFiber.alternate === null) { // 将老的fiber 添加 ChildDeletion 标记 deleteChild(returnFiber, oldFiber); } } // 取 current.index 和 lastPlacedIndex 最大值 // 并给 newFiber.flag 添加 Placement / Forked 标记 lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx); // 建立 newFiber 之间的联系 if (previousNewFiber === null) { resultingFirstChild = newFiber; } else { previousNewFiber.sibling = newFiber; } previousNewFiber = newFiber; oldFiber = nextOldFiber; } // 遍历跳出之后，会判断老fiber或者是新ReactElement遍历完成没。 // 如果 newChildren 遍历完成，那么所有剩余的老fiber都应该标记为删除 if (newIdx === newChildren.length) { // 标记删除，记录到 父 fiber 的 deletions 属性中 deleteRemainingChildren(returnFiber, oldFiber); return resultingFirstChild; } // 如果老fiber遍历完成，那么所有剩余新的ReactElement都是新插入的节点，创建newFiber if (oldFiber === null) { for (; newIdx \u0026lt; newChildren.length; newIdx++) { // 根据 ReactElement 创建 fiber const newFiber = createChild(returnFiber, newChildren[newIdx], lanes); if (newFiber === null) { continue; } // 为 newFiber.flage 添加 place 标记 lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx); if (previousNewFiber === null) { // TODO: Move out of the loop. This only happens for the first run. resultingFirstChild = newFiber; } else { previousNewFiber.sibling = newFiber; } previousNewFiber = newFiber; } return resultingFirstChild; } // 后续的是因为 key 和 type 不一致导致没有遍历完的数组。 // 此时开始复用的算法。 // 首先将老节点转换为 map 形式：{ key|index : fiber } const existingChildren = mapRemainingChildren(returnFiber, oldFiber); for (; newIdx \u0026lt; newChildren.length; newIdx++) { // 从 existingChildren 中匹配 newIdx / newChild.key， // 若匹配到 则调用 useFiber 复用拿出存储的 oldFiber // 否则创建 新fiber const newFiber = updateFromMap( existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes ); if (newFiber !== null) { if (shouldTrackSideEffects) { if (newFiber.alternate !== null) { // 如果已经复用了，在 map 中删除对应的 fiber existingChildren.delete( newFiber.key === null ? newIdx : newFiber.key ); } } // 能复用时，更新最后一个复用的 老fiber 的 index lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx); if (previousNewFiber === null) { resultingFirstChild = newFiber; } else { previousNewFiber.sibling = newFiber; } previousNewFiber = newFiber; } } if (shouldTrackSideEffects) { // 将所有没有被复用的老fiber标记为删除 existingChildren.forEach((child) =\u0026gt; deleteChild(returnFiber, child)); } return resultingFirstChild; } // 用于 diff 算法，标记最后匹配的 old fiber 的位置 function placeChild( newFiber: Fiber, lastPlacedIndex: number, newIndex: number ): number { newFiber.index = newIndex; // 当父亲的 current 不存在时，此时为 mount，shouldTrackSideEffects 为 false，不用做处理。 // 当父亲的 current 存在时，shouldTrackSideEffects 为 true。 // 例如，当遇到第一个需要重新创建的节点时，它对应的 parent 的 current 存在，标记为更新。 // 当遍历到子节点时，由于子节点对应的 parent 的 current 不存在，此时不标记更新。 // 这样做的好处是，只有父亲被标记为更新，而其后代均不作标记。 // 在 completeWork 的时候子节点直接全添加到父亲上。 // 在 commit 的时候只需要将父亲添加到 根节点上即可。 if (!shouldTrackSideEffects) { return lastPlacedIndex; } // 如果复用了 老fiber const current = newFiber.alternate; if (current !== null) { const oldIndex = current.index; // 如果老的 index \u0026lt; lastPlacedIndex，说明这些老的节点无法复用。 if (oldIndex \u0026lt; lastPlacedIndex) { // 不可复用，需要替换 newFiber.flags |= Placement; return lastPlacedIndex; } else { // This item can stay in place. // 否则说明这个老节点可以复用，返回老节点 index return oldIndex; } } else { // 如果 老 fiber不存在，那么需要替换 // 注意这里被标记了，commit的时候会进行处理 newFiber.flags |= Placement; return lastPlacedIndex; } } ","date":"2025-01-17","externalUrl":null,"permalink":"/react/beginwork_fiber/","section":"Reacts","summary":"聚焦 react fiber 调度的单元 beginWork 大致梳理其如何创建/更新/diff fiber 的","title":"React18 阅读笔记 -- beginwork fiber","type":"react"},{"content":" commitRoot # beginWork 和 completeWork 阶段都正常结束后，此时所有的 fiber 和真实节点创建完成，进入到 commit 阶段：\nfinishConcurrentRender(root, exitStatus, lanes) { switch (exitStatus) { case RootCompleted: { // The work completed. Ready to commit. commitRoot( root, workInProgressRootRecoverableErrors, workInProgressTransitions, ) break; } } } function commitRoot(root) { const previousUpdateLanePriority = getCurrentUpdatePriority(); const prevTransition = ReactCurrentBatchConfig.transition; try { ReactCurrentBatchConfig.transition = 0; // 优先级为同步，不可被打断 setCurrentUpdatePriority(DiscreteEventPriority); commitRootImpl(root, previousUpdateLanePriority); } finally { ReactCurrentBatchConfig.transition = prevTransition; setCurrentUpdatePriority(previousUpdateLanePriority); } return null; } commitRootImpl # 具体执行方法，先检测是否有上轮更新未执行的 effect，如果有则先调用 flushPassiveEffects 同步执行上轮遗留 effect 任务。 否则通过 scheduleCallback 将 本轮 effect 加入到 任务队列(taskQueue)中。\nfunction commitRootImpl( root: FiberRoot, recoverableErrors: null | Array\u0026lt;CapturedValue\u0026lt;mixed\u0026gt;\u0026gt;, transitions: Array\u0026lt;Transition\u0026gt; | null, renderPriorityLevel: EventPriority ) { do { flushPassiveEffects(); } while (rootWithPendingPassiveEffects !== null); const finishedWork = root.finishedWork; const lanes = root.finishedLanes; root.finishedWork = null; root.finishedLanes = NoLanes; root.callbackNode = null; root.callbackPriority = NoLane; // 如果flags/subtreeFlags中存在PassiveMask，即Passive|ChildDeletion， // 那么 rootDoesHavePassiveEffects 为true。也就是说如果使用了useEffect或者是节点有删除的情况 // 那么就会执行flushPassiveEffects方法： if ( (finishedWork.subtreeFlags \u0026amp; PassiveMask) !== NoFlags || (finishedWork.flags \u0026amp; PassiveMask) !== NoFlags ) { if (!rootDoesHavePassiveEffects) { rootDoesHavePassiveEffects = true; // 异步执行 useEffect scheduleCallback(NormalSchedulerPriority, () =\u0026gt; { flushPassiveEffects(); return null; }); } } // 如果subtreeHasEffects或rootHasEffect存在，说明有更新。 // 首先会进入beforeMutation阶段，调用commitBeforeMutationEffects方法： if (subtreeHasEffects || rootHasEffect) { const shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects( root, finishedWork ); } commitMutationEffects(root, finishedWork, lanes); // 同步执行 useLayoutEffect 的 create 并存储 destroy commitLayoutEffects(finishedWork, root, lanes); if (rootDoesHavePassiveEffects) { rootDoesHavePassiveEffects = false; rootWithPendingPassiveEffects = root; pendingPassiveEffectsLanes = lanes; } root.current = finishedWork; // 如果还有未完成的更新，即优先级不够的更新，那么这里会被继续调度进行更新。 ensureRootIsScheduled(root, now()); // 如果当前更新中包含useEffect，并且lanes中含有同步lane，那么需要立即执行flushPassiveEffect // 相比于schedule执行flushPassiveEffects，这里执行更靠前。 if ( includesSomeLane(pendingPassiveEffectsLanes, SyncLane) \u0026amp;\u0026amp; root.tag !== LegacyRoot ) { flushPassiveEffects(); } flushSyncCallbacks(); return null; } // flushPassiveEffects export function flushPassiveEffects(): boolean { // 如果 rootWithPendingPassiveEffects 存在，说明使用了 useEffect 或者有子节点被删除 if (rootWithPendingPassiveEffects !== null) { const renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes); const priority = lowerEventPriority(DefaultEventPriority, renderPriority); const prevTransition = ReactCurrentBatchConfig.transition; const previousPriority = getCurrentUpdatePriority(); try { // transition 置为 0 ReactCurrentBatchConfig.transition = 0; // 设置 update 优先级，获取 lane 的时候会用得到 setCurrentUpdatePriority(priority); return flushPassiveEffectsImpl(); } finally { setCurrentUpdatePriority(previousPriority); ReactCurrentBatchConfig.transition = prevTransition; } } return false; } function flushPassiveEffectsImpl() { if (rootWithPendingPassiveEffects === null) { return false; } // 针对 fiber.flags === ChildDeletion 的 节点 执行 // commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor); // 对 function 组件 通过调用 // safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy); // 方法 执行 destroy。然后在 // commitPassiveUnmountEffectsInsideOfDeletedTree_complete // 方法中删除fiber引用并且删除对应真实节点的引用 // 到底后 执行 commitPassiveUnmountInsideDeletedTreeOnFiber 自下而上处理兄弟节点 commitPassiveUnmountEffects(root.current); // 同上步骤 调用effects里的 create 方法并生成destroy commitPassiveMountEffects(root, root.current, lanes, transitions); flushSyncCallbacks(); } BeforeMutationEffects # // BeforeMutationEffects 阶段 export function commitBeforeMutationEffects( root: FiberRoot, firstChild: Fiber ) { focusedInstanceHandle = prepareForCommit(root.containerInfo); nextEffect = firstChild; commitBeforeMutationEffects_begin(); // 。。。省略部分代码 } function commitBeforeMutationEffects_begin() { // 向下遍历，直到找到一个不符合BeforeMutationMask的节点 while (nextEffect !== null) { const fiber = nextEffect; const child = fiber.child; // export const BeforeMutationMask = Update | Snapshot if ( (fiber.subtreeFlags \u0026amp; BeforeMutationMask) !== NoFlags \u0026amp;\u0026amp; child !== null ) { child.return = fiber; nextEffect = child; } else { commitBeforeMutationEffects_complete(); } } } // 自下往上遍历，执行 commitBeforeMutationEffectsOnFiber function commitBeforeMutationEffects_complete() { while (nextEffect !== null) { const fiber = nextEffect; // 处理 class组件中定义的getSnapshotBeforeUpdate函数 // 或者 处理 current === null || current.child === null 的HostRoot // 将 root.containerInfo 真实节点的内容置空 commitBeforeMutationEffectsOnFiber(fiber); const sibling = fiber.sibling; if (sibling !== null) { sibling.return = fiber.return; nextEffect = sibling; return; } nextEffect = fiber.return; } } mutation # export function commitMutationEffects( root: FiberRoot, finishedWork: Fiber, committedLanes: Lanes ) { inProgressLanes = committedLanes; inProgressRoot = root; // mutation阶段的执行顺序也是自上而下开始遍历，执行删除dom操作，然后到了最底层子节点， // 开始自下而上执行插入和更新dom操作 commitMutationEffectsOnFiber(finishedWork, root, committedLanes); inProgressLanes = null; inProgressRoot = null; } function commitMutationEffectsOnFiber( finishedWork: Fiber, root: FiberRoot, lanes: Lanes ) { const current = finishedWork.alternate; const flags = finishedWork.flags; // The effect flag should be checked *after* we refine the type of fiber, // because the fiber tag is more specific. An exception is any flag related // to reconcilation, because those can be set on all fiber types. switch (finishedWork.tag) { case FunctionComponent: case ForwardRef: case MemoComponent: case SimpleMemoComponent: { // Deletion 深度遍历执行删除操作 recursivelyTraverseMutationEffects(root, finishedWork, lanes); // Placement 插入逻辑 commitReconciliationEffects(finishedWork); if (flags \u0026amp; Update) { // 找出 useInsertionEffect 的 destroy 方法去调用 // 需要注意 destroy 可能为 undefined（函数组件初次挂载的情况下） commitHookEffectListUnmount( HookInsertion | HookHasEffect, finishedWork, finishedWork.return, ); // 执行 useInsertionEffect 的回调函数，并将返回值保存到 effect.destory 里。 commitHookEffectListMount( HookInsertion | HookHasEffect, finishedWork, ); if ( enableProfilerTimer \u0026amp;\u0026amp; enableProfilerCommitHooks \u0026amp;\u0026amp; finishedWork.mode \u0026amp; ProfileMode ) { startLayoutEffectTimer(); // useLayoutEffect 对应的 destroy 方法 // 同样可能不存在 commitHookEffectListUnmount( HookLayout | HookHasEffect, finishedWork, finishedWork.return, ); recordLayoutEffectDuration(finishedWork); } } return; } case HostComponent: { recursivelyTraverseMutationEffects(root, finishedWork, lanes); commitReconciliationEffects(finishedWork); } } 流程图 # commit 流程图 ","date":"2025-01-17","externalUrl":null,"permalink":"/react/commit/","section":"Reacts","summary":"commit阶段 处理 fiber 创建/更新 遗留的 副作用 值得一提的是 useEffect 在该阶段会通过 microTask 方式放到微任务队列等待当前同步代码执行完成后再执行","title":"React18 阅读笔记 -- commit","type":"react"},{"content":"","date":"2025-01-13","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":" 快速上手 # Zustand 是基于 React Hook 构建的状态管理库，它的设计理念是让状态管理变得简单、直观。只需寥寥数行代码，就能轻松管理应用的状态。\n特点 # 轻量级：Zustand 的体积非常小，几乎没有任何依赖，生产级包体积不到 1kb，这使得它在项目中引入时不会带来过多的负担，能够保持项目的轻量化。 基于 React Hook：完全基于 React Hook 构建，契合函数式编程，开发者可以利用熟悉的 Hook 语法来管理状态，避免了复杂的类组件写法和样板代码。 简单易用：API 简洁明了，有完备的使用文档，源码清晰且不多，学习成本低、曲线顺畅。 高性能：能够精确地追踪状态的变化，只重新渲染依赖该状态的组件，从而提高应用的性能和响应速度。 可扩展性：支持中间件和插件机制，开发者可以根据项目需求轻松地扩展其功能，如添加日志记录、持久化状态等。 安装 Zustand # 使用 npm 或 yarn 安装 Zustand，为项目引入这个强大的状态管理工具：\nnpm install zustand # 或者 yarn add zustand 创建第一个状态 # 以一个简单的计数器为例，看看如何使用 Zustand 创建和管理状态：\nimport create from \u0026#34;zustand\u0026#34;; const useCounter = create((set) =\u0026gt; ({ count: 0, increment: () =\u0026gt; set((state) =\u0026gt; ({ count: state.count + 1 })), decrement: () =\u0026gt; set((state) =\u0026gt; ({ count: state.count - 1 })) })); 在这段代码中，create函数接收一个回调函数，通过set方法来更新状态。set方法既可以接收一个新的状态对象，也可以接收一个函数，该函数接收当前状态并返回新状态，确保状态更新的不可变性。\n在 React 使用 # 在 React 中，通过useCounter这个自定义 Hook 来获取和更新状态：\nimport React from \u0026#34;react\u0026#34;; import useCounter from \u0026#34;./useCounter\u0026#34;; const CounterComponent = () =\u0026gt; { const { count, increment, decrement } = useCounter(); // const increment = useCounter((state) =\u0026gt; state.increment); // const decrement = useCounter((state) =\u0026gt; state.decrement); return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={increment}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;button onClick={decrement}\u0026gt;Decrement\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export default CounterComponent; 这里使用useCounter的回调函数，精准地获取和操作所需的状态。这种方式被称为“selector”，它可以只返回组件关心的状态部分，避免不必要的重新渲染，极大地提升了性能。\n处理复杂状态 # 复杂状态管理与 Immer 的结合 # 当处理复杂的状态结构时，Zustand 可以与 Immer 库结合使用，让状态更新变得更加简洁和直观。Immer 允许我们以可变的方式编写代码，而底层会自动处理不可变数据的更新。\nimport create from \u0026#34;zustand\u0026#34;; import produce from \u0026#34;immer\u0026#34;; const useTodoStore = create((set) =\u0026gt; ({ todos: [], addTodo: (text) =\u0026gt; set( produce((state) =\u0026gt; { state.todos.push({ id: Date.now(), text, completed: false }); }) ), toggleTodo: (id) =\u0026gt; set( produce((state) =\u0026gt; { const todo = state.todos.find((t) =\u0026gt; t.id === id); if (todo) { todo.completed = !todo.completed; } }) ) })); 通过 Immer 的produce函数，我们可以像操作普通对象一样更新状态，而无需手动处理复杂的不可变数据结构。\n中间件 # Zustand 支持中间件，通过中间件可以轻松扩展状态管理的功能。例如，使用zustand - middleware - logger中间件来记录状态的变化，方便调试：\nnpm install zustand-middleware-logger # 或者 yarn add zustand-middleware-logger import create from \u0026#34;zustand\u0026#34;; import logger from \u0026#34;zustand-middleware-logger\u0026#34;; const useCounter = create( logger((set) =\u0026gt; ({ count: 0, increment: () =\u0026gt; set((state) =\u0026gt; ({ count: state.count + 1 })), decrement: () =\u0026gt; set((state) =\u0026gt; ({ count: state.count - 1 })) })) ); 添加中间件后，每次状态更新时，控制台都会输出详细的日志信息，帮助我们快速定位问题。\n源码浅析（react 部分） # create # create函数是 Zustand 的核心，它负责创建状态管理实例。其基本实现思路是创建一个包含状态和更新方法的对象，并返回一个自定义 Hook。这个 Hook 内部维护了一个状态的订阅者列表，当状态发生变化时，会通知所有订阅者重新渲染。\nfunction create(setter) { let state; let listeners = new Set(); const setState: StoreApi\u0026lt;TState\u0026gt;[\u0026#39;setState\u0026#39;] = (partial, replace) =\u0026gt; { const nextState = typeof partial === \u0026#39;function\u0026#39; ? (partial as (state: TState) =\u0026gt; TState)(state) : partial if (!Object.is(nextState, state)) { const previousState = state state = (replace ?? (typeof nextState !== \u0026#39;object\u0026#39; || nextState === null)) ? (nextState as TState) : Object.assign({}, state, nextState) listeners.forEach((listener) =\u0026gt; listener(state, previousState)) } } const getState: StoreApi\u0026lt;TState\u0026gt;[\u0026#39;getState\u0026#39;] = () =\u0026gt; state const subscribe: StoreApi\u0026lt;TState\u0026gt;[\u0026#39;subscribe\u0026#39;] = (listener) =\u0026gt; { listeners.add(listener) // Unsubscribe return () =\u0026gt; listeners.delete(listener) } const getInitialState: StoreApi\u0026lt;TState\u0026gt;[\u0026#39;getInitialState\u0026#39;] = () =\u0026gt; initialState const initialState = setter(setState); const api = { setState, getState, getInitialState, subscribe } const initialState = (state = createState(setState, getState, api)) return api as any } 在这个简化的实现中， create函数接收一个setter函数，通过setState方法来更新状态，并通知所有订阅者。返回的自定义 Hook 则负责根据selector获取状态，并在状态变化时重新计算selector的值。\nuseStore Hook # useStore Hook 是 Zustand 与 React 组件交互的桥梁。它通过 React 的useState和useEffect Hook 来实现状态的订阅和更新。当组件使用useStore时，会将自身添加到状态的订阅者列表中，当状态发生变化时，会触发组件的重新渲染。\nimport { useSyncExternalStore } from \u0026#34;react\u0026#34;; const identity = \u0026lt;T\u0026gt;(arg: T): T =\u0026gt; arg; export function useStore\u0026lt;TState, StateSlice\u0026gt;( api: ReadonlyStoreApi\u0026lt;TState\u0026gt;, selector: (state: TState) =\u0026gt; StateSlice = identity as any ) { const slice = useSyncExternalStore( api.subscribe, () =\u0026gt; selector(api.getState()), () =\u0026gt; selector(api.getInitialState()) ); React.useDebugValue(slice); return slice; } 在实际的 Zustand 源码中，useStore的实现更加复杂，它还处理了selector的缓存、中间件的调用等功能，但基本原理与上述代码类似。\n总结 # Zustand 以其简洁的 API、高效的性能和灵活的扩展性，为 React 开发者提供了一种优秀的状态管理解决方案。通过深入了解 Zustand 在 React 中的使用方法和源码实现，我们不仅能够更好地运用这一工具，还能从中汲取设计灵感，提升自己的编程能力。\n在未来，随着 React 生态的不断发展，相信 Zustand 也会持续演进，为开发者带来更多便利和惊喜。无论是小型项目的快速迭代，还是大型应用的复杂状态管理，Zustand 都值得我们深入学习和使用。\n希望本文能帮助你对 Zustand 有更深入的理解，如果你在使用 Zustand 的过程中有任何问题或心得，欢迎在评论区分享交流！\n","date":"2025-01-13","externalUrl":null,"permalink":"/posts/zustand/","section":"Posts","summary":"文章主要介绍了Zustand这一React状态管理库，包括其简介、优势、使用方法、与Redux对比、踩坑点、中间件、选择理由、工作原理等。Zustand轻量简洁，API友好，支持TypeScript，具有性能优化、灵活可扩展等优点，可轻松集成和处理异步操作，能完美替代某些传统状态管理库的不足，在实际使用中有多种优化和配置方式。","title":"React 中使用 Zustand 状态管理库 及其源码解析","type":"posts"},{"content":" New article! ReactDOM.createRoot # 创建了一个 reactfiberrootnode current 属性指向一个新 fiber,并绑定所有事件监听\n/** * 创建 tag = 1 的 FiberRoot 对象 * 并在current 上挂载了一个 tag = 3, mode = 1 的空fiber * 初始化该 fiber 的 UpdateQueue initializeUpdateQueue(uninitializedFiber) */ const root = createContainer( container, ConcurrentRoot, // 常量 1 null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks, ); // container[__reactContainer$(一串随机数)] = root.current; markContainerAsRoot(root.current, container); const rootContainerElement: Document | Element | DocumentFragment = container.nodeType === COMMENT_NODE ? (container.parentNode: any) : container; /** 为 container 添加事件监听 */ listenToAllSupportedEvents(rootContainerElement); /** * this._internalRoot = internalRoot; * 挂载到 ReactDOMRoot._internalRoot 属性上 */ return new ReactDOMRoot(root); render 入口 # // path: packages/react-dom/src/client/ReactDomRoot.js ReactDOMRoot.prototype.render = function (children: ReactNodeList): void { // ...省略部分代码 updateContainer(children, root, null, null); }; // path: packages/react-reconciler/src/ReactFiberReconciler.old.js function updateContainer( element: ReactNodeList, // Index container: OpaqueRoot, // root parentComponent: ?React$Component\u0026lt;any, any\u0026gt;, // null callback: ?Function // null ): Lane { // 初始化一个 update 任务 const update = createUpdate(eventTime, lane); update.payload = { element }; /** * 将创建的 update任务 添加到 ReactFiberConcurrentUpdates 文件 * 全局变量 concurrentQueues 中 * 用传入的 lane 更新fiber链表中的所有 lane 并返回 root * */ const fiber = container.current; const queue: SharedQueue\u0026lt;State\u0026gt; = fiber.updateQueue.shared; const interleaved = queue.interleaved; if (interleaved === null) { update.next = update; ReactFiberConcurrentUpdates.concurrentQueues = [queue]; } queue.interleaved = update; // 上面是 enqueueUpdate 方法的具体实现 执行栈太长就把重要步骤挪过来方便查看了 const root = markUpdateLaneFromFiberToRoot(fiber, lane); if (root !== null) { scheduleUpdateOnFiber(root, current, lane, eventTime); entangleTransitions(root, current, lane); } } scheduleUpdateOnFiber # // path: packages/react-reconciler/src/ReactFiberWorkLoop.old.js function scheduleUpdateOnFiber( root: FiberRoot, fiber: Fiber, lane: Lane, eventTime: number ) { // 将 eventTime 按 lane 插入到 root.eventTimes 中 markRootUpdated(root, lane, eventTime); // 做的事情蛮多 ensureRootIsScheduled(root, eventTime); } // ensureRootIsScheduled function ensureRootIsScheduled(root: FiberRoot, currentTime: number) { //根据 root.eventTimes 计算出 root.expirationTimes markRootUpdated(root, lane, eventTime); const nextLanes = getNextLanes(root, NoLanes); const newCallbackPriority = getHighestPriorityLane(nextLanes); const existingCallbackNode = root.callbackNode; if (existingCallbackNode != null) { // Cancel the existing callback. We\u0026#39;ll schedule a new one below. cancelCallback(existingCallbackNode); } let newCallbackNode = scheduleCallback( schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root) ); root.callbackPriority = newCallbackPriority; root.callbackNode = newCallbackNode; } scheduleCallback # 通过 postMessage 建立一个 宏任务 启动挂载\nfunction scheduleCallback(priorityLevel, callback) { // 这里调用的就是 Scheduler 中的 unstable_scheduleCallback 方法 return Scheduler_scheduleCallback(priorityLevel, callback); } // path: packages/scheduler/src/forks/Scheduler.js function unstable_scheduleCallback(priorityLevel, callback, options) { var currentTime = getCurrentTime(); var startTime = currentTime; // NormalPriority 是 5000 var timeout = 5000; var expirationTime = startTime + timeout; var newTask = { id: taskIdCounter++, callback, // performConcurrentWorkOnRoot 方法 priorityLevel, startTime, expirationTime, sortIndex: -1 }; newTask.sortIndex = expirationTime; // 将 newTask 放进 taskQueue 并按照 sortIndex 排序 push(taskQueue, newTask); // 挂载时都为初始值 false if (!isHostCallbackScheduled \u0026amp;\u0026amp; !isPerformingWork) { isHostCallbackScheduled = true; function requestHostCallback(callback) { scheduledHostCallback = callback; // 挂载时都为初始值 false if (!isMessageLoopRunning) { isMessageLoopRunning = true; // 通过 postMessage 异步调用 performWorkUntilDeadline schedulePerformWorkUntilDeadline(); } } requestHostCallback(flushWork); } } // path: packages/scheduler/src/forks/Scheduler.js const performWorkUntilDeadline = () =\u0026gt; { const currentTime = getCurrentTime(); let hasMoreWork = true; try { // 这里的 scheduledHostCallback 就是 flushWork hasMoreWork = scheduledHostCallback(true, currentTime); } finally { // 还有任务则再调一轮 if (hasMoreWork) { schedulePerformWorkUntilDeadline(); } else { isMessageLoopRunning = false; scheduledHostCallback = null; } } }; flushWork # 循环调度 宏任务（挂载时只 push 了 一个 task）\n// path: packages/scheduler/src/forks/Scheduler.js // hasTimeRemaining = true ,initialTime = currentTime function flushWork(hasTimeRemaining, initialTime) { isHostCallbackScheduled = false; isPerformingWork = true; // 这里的 currentPriorityLevel 为初始值 3 const previousPriorityLevel = currentPriorityLevel; try { return workLoop(hasTimeRemaining, initialTime); } finally { currentTask = null; currentPriorityLevel = previousPriorityLevel; isPerformingWork = false; if (enableProfiling) { const currentTime = getCurrentTime(); markSchedulerSuspended(currentTime); } } } // path: packages/scheduler/src/forks/Scheduler.js function workLoop(hasTimeRemaining, initialTime) { let currentTime = initialTime; currentTask = peek(taskQueue); while (currentTask !== null) { // 这里的 callback 就是 performConcurrentWorkOnRoot const callback = currentTask.callback; if (typeof callback === \u0026#34;function\u0026#34;) { currentTask.callback = null; currentPriorityLevel = currentTask.priorityLevel; const didUserCallbackTimeout = currentTask.expirationTime \u0026lt;= currentTime; // 至此 任务调度 完成，开始执行任务 进入 reconciler 阶段 const continuationCallback = callback(didUserCallbackTimeout); currentTime = getCurrentTime(); if (typeof continuationCallback === \u0026#34;function\u0026#34;) { currentTask.callback = continuationCallback; } else { if (currentTask === peek(taskQueue)) { pop(taskQueue); } } } } } performConcurrentWorkOnRoot # 调用 workLoopSync 开始 递归创建 fiber\n// path: packages/react-reconciler/src/ReactFiberWorkLoop.old.js function performConcurrentWorkOnRoot(root, didTimeout) { const originalCallbackNode = root.callbackNode; /** 刷新pending状态的effects, 有可能某些effect会取消本次任务 */ const didFlushPassiveEffects = flushPassiveEffects(); let lanes = getNextLanes(root, NoLanes); let exitStatus = renderRootSync(root, lanes); if (![0, 1, 2, 6].includes(exitStatus)) { root.finishedWork = finishedWork; root.finishedLanes = lanes; // !调和阶段完成 提交fiber树 finishConcurrentRender(root, exitStatus, lanes); } ensureRootIsScheduled(root, now()); // 若还是同一个任务则继续返回该任务 if (root.callbackNode === originalCallbackNode) { return performConcurrentWorkOnRoot.bind(null, root); } return null; } function renderRootSync(root: FiberRoot, lanes: Lanes) { // 存储 executionContext const prevExecutionContext = executionContext; // 将 executionContext 更新为 RenderContext executionContext |= RenderContext; ReactCurrentDispatcher.current = ContextOnlyDispatcher; // 如果workinprogress不存在 则初始化一个 // 并将 queue.interleaved 移到 queue.pending 中 // 这里的 queue 存的是 root.current.updateQueue.shared // 在 enqueueConcurrentClassUpdate 方法中给 queue.interleaved 赋值为 update; // 该update 是在 updateContainer 方法中 创建的 并将 payload属性赋值为了 render方法里的 第一个参数 prepareFreshStack(root, lanes); do { try { workLoopSync(); break; } catch (thrownValue) { handleError(root, thrownValue); } } while (true); return workInProgressRootExitStatus; } function workLoopSync() { while (workInProgress !== null) { performUnitOfWork(workInProgress); } } performUnitOfWork # 进入到最小调度单元，递归创建 fiber 并链接到workinprogress\nfunction performUnitOfWork(unitOfWork: Fiber): void { const current = unitOfWork.alternate; let next; // 用来存放beginWork()返回的结果 // 根据 workInProgress.tag 创建对应 fiber // 若 为 函数组件 则调用 renderWidthHook 执行函数组件 并 创建对应fiber next = beginWork(current, unitOfWork, subtreeRenderLanes); // 更新状态了 unitOfWork.memoizedProps = unitOfWork.pendingProps; if (next === null) { // If this doesn\u0026#39;t spawn new work, complete the current work. completeUnitOfWork(unitOfWork); } else { // 下次的workLoopSync/workLoopConcurrent的while循环的循环主体为子Fiber节点 workInProgress = next; } } function completeUnitOfWork(unitOfWork: Fiber): void { // 本次 performUnitOfWork 的循环主体 workInprogress 的最底层 child let completedWork = unitOfWork; do { const current = completedWork.alternate; const returnFiber = completedWork.return; // 只要 beginWork 阶段正常执行后（即执行无异常），都会进到这一段逻辑来 let next; next = completeWork(current, completedWork, subtreeRenderLanes); resetCurrentDebugFiberInDEV(); if (next !== null) { workInProgress = next; return; } // 取当前Fiber节点(completedWork)的兄弟(sibling)节点； // 如果有值，则结束completeUnitOfWork，并将该兄弟节点作为下次performUnitOfWork的主体(unitOfWork) const siblingFiber = completedWork.sibling; if (siblingFiber !== null) { // If there is more work to do in this returnFiber, do that next. workInProgress = siblingFiber; return; } // Otherwise, return to the parent // 若没有兄弟节点，则将在下次do...while循环中处理父节点(completedWork.return) completedWork = returnFiber; // Update the next thing we\u0026#39;re working on in case something throws. // 此处需要注意！ // 虽然把workInProgress置为completedWork，但由于没有return，即没有结束completeUnitOfWork，因此没有意义 // 直到completedWork（此时实际上是本循环中原completedWork.return）为null，结束do...while循环后 // 此时completeUnitOfWork的运行结果(workInProgress)为null // 也意味着performSyncWorkOnRoot/performConcurrentWorkOnRoot中的while循环也达到了结束条件 workInProgress = completedWork; } while (completedWork !== null); // We\u0026#39;ve reached the root. if (workInProgressRootExitStatus === RootInProgress) { workInProgressRootExitStatus = RootCompleted; } } finishConcurrentRender # wrokinprogress树创建完成 开始 commit\nfinishConcurrentRender(root, exitStatus, lanes) { switch (exitStatus) { case RootCompleted: { // The work completed. Ready to commit. commitRoot( root, workInProgressRootRecoverableErrors, workInProgressTransitions, ) break; } } } function commitRootImpl( root: FiberRoot, recoverableErrors: null | Array\u0026lt;CapturedValue\u0026lt;mixed\u0026gt;\u0026gt;, transitions: Array\u0026lt;Transition\u0026gt; | null, renderPriorityLevel: EventPriority, ) { do { flushPassiveEffects() } while (rootWithPendingPassiveEffects !== null); const finishedWork = root.finishedWork; const lanes = root.finishedLanes; root.finishedWork = null; root.finishedLanes = NoLanes; root.callbackNode = null; root.callbackPriority = NoLane; if (!rootDoesHavePassiveEffects) { rootDoesHavePassiveEffects = true; pendingPassiveEffectsRemainingLanes = remainingLanes; pendingPassiveTransitions = transitions; scheduleCallback(NormalSchedulerPriority, () =\u0026gt; { flushPassiveEffects(); return null; }); } if (subtreeHasEffects || rootHasEffect) { const shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects( root, finishedWork, ); } } ","date":"2025-01-13","externalUrl":null,"permalink":"/react/render%E8%B0%83%E5%BA%A6/","section":"Reacts","summary":"从 render 入口函数 开始 debug react18 源码，梳理 主体流程 有哪些步骤","title":"React18 阅读笔记 -- render 调度阶段","type":"react"},{"content":"","date":"2025-01-13","externalUrl":null,"permalink":"/tags/zustand/","section":"Tags","summary":"","title":"Zustand","type":"tags"},{"content":"","date":"2025-01-13","externalUrl":null,"permalink":"/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/","section":"Tags","summary":"","title":"状态管理","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"}]