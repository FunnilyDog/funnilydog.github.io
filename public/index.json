


[{"content":"","date":"2025-01-18","externalUrl":null,"permalink":"/","section":"FunnilyDog‘s Site","summary":"","title":"FunnilyDog‘s Site","type":"page"},{"content":"","date":"2025-01-18","externalUrl":null,"permalink":"/notes/","section":"Notes","summary":"","title":"Notes","type":"notes"},{"content":"","date":"2025-01-18","externalUrl":null,"permalink":"/series/react18-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","section":"Series","summary":"","title":"React18 阅读笔记","type":"series"},{"content":" 入口 # function beginWork( current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes ): Fiber | null { // ...省略，这里只关注 switch case 部分 // 这里列举全部 case，下面会对部分case进行梳理 switch (workInProgress.tag) { // 挂载时, 此时的 function class 组件还未区分，都走该case case IndeterminateComponent: { return mountIndeterminateComponent( current, workInProgress, workInProgress.type, renderLanes ); } case LazyComponent: { const elementType = workInProgress.elementType; return mountLazyComponent( current, workInProgress, elementType, renderLanes ); } case FunctionComponent: { const Component = workInProgress.type; const unresolvedProps = workInProgress.pendingProps; const resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps); return updateFunctionComponent( current, workInProgress, Component, resolvedProps, renderLanes ); } case ClassComponent: { const Component = workInProgress.type; const unresolvedProps = workInProgress.pendingProps; const resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps); return updateClassComponent( current, workInProgress, Component, resolvedProps, renderLanes ); } // 在 create 中 已梳理 case HostRoot: return updateHostRoot(current, workInProgress, renderLanes); case HostComponent: return updateHostComponent(current, workInProgress, renderLanes); case SuspenseComponent: return updateSuspenseComponent(current, workInProgress, renderLanes); case HostPortal: return updatePortalComponent(current, workInProgress, renderLanes); case ForwardRef: { const type = workInProgress.type; const unresolvedProps = workInProgress.pendingProps; const resolvedProps = workInProgress.elementType === type ? unresolvedProps : resolveDefaultProps(type, unresolvedProps); return updateForwardRef( current, workInProgress, type, resolvedProps, renderLanes ); } case Mode: return updateMode(current, workInProgress, renderLanes); case Profiler: return updateProfiler(current, workInProgress, renderLanes); case ContextProvider: return updateContextProvider(current, workInProgress, renderLanes); case ContextConsumer: return updateContextConsumer(current, workInProgress, renderLanes); case MemoComponent: { const type = workInProgress.type; const unresolvedProps = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props. let resolvedProps = resolveDefaultProps(type, unresolvedProps); resolvedProps = resolveDefaultProps(type.type, resolvedProps); return updateMemoComponent( current, workInProgress, type, resolvedProps, renderLanes ); } // ...省略部分 case } } case 梳理 # 在梳理具体 case 之前，将简单介绍部分 公共方法\nexport function prepareToReadContext( workInProgress: Fiber, renderLanes: Lanes ): void { currentlyRenderingFiber = workInProgress; lastContextDependency = null; lastFullyObservedContext = null; const dependencies = workInProgress.dependencies; if (dependencies !== null) { const firstContext = dependencies.firstContext; if (firstContext !== null) { if (includesSomeLane(dependencies.lanes, renderLanes)) { //将 ReactFiberBeginWork 中的 局部属性 didReceiveUpdate 值更改为 true; markWorkInProgressReceivedUpdate(); } dependencies.firstContext = null; } } } IndeterminateComponent # 函数组件 \u0026amp; 类组件 首次挂载时都会走到该 case 会先执行 renderWithHooks 方法 后 判断 value 是否有 render 方法 来确认是 函数组件 or 类组件 并给 fiber 打标。函数组件 类组件 具体实现 在对应 case 中梳理\nfunction mountIndeterminateComponent( _current, workInProgress, Component, renderLanes ) { const props = workInProgress.pendingProps; let context; prepareToReadContext(workInProgress, renderLanes); value = renderWithHooks( null, workInProgress, Component, props, context, renderLanes ); if ( typeof value === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; value !== null \u0026amp;\u0026amp; typeof value.render === \u0026#34;function\u0026#34; \u0026amp;\u0026amp; value.$$typeof === undefined ) { workInProgress.tag = ClassComponent; // TODO 类组件挂载时 具体实现流程梳理 } else { workInProgress.tag = FunctionComponent; // 将子节点 reconcileChildren(null, workInProgress, value, renderLanes); return workInProgress.child; } } FunctionComponent # function updateFunctionComponent( current, workInProgress, Component, nextProps: any, renderLanes ) { // ... let context, nextChildren, hasId; prepareToReadContext(workInProgress, renderLanes); nextChildren = renderWithHooks( current, workInProgress, Component, nextProps, context, renderLanes ); // ...省略部分代码 只关注 主要步骤 // React DevTools reads this flag. workInProgress.flags |= PerformedWork; reconcileChildren(current, workInProgress, nextChildren, renderLanes); return workInProgress.child; } renderWithHooks # export function renderWithHooks\u0026lt;Props, SecondArg\u0026gt;( current: Fiber | null, workInProgress: Fiber, Component: (p: Props, arg: SecondArg) =\u0026gt; any, props: Props, secondArg: SecondArg, nextRenderLanes: Lanes ): any { // 将 HooksDispatcher 切换为 update ReactCurrentDispatcher.current = current === null || current.memoizedState === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate; // 这里的 Component 则为具体的 函数组件 let children = Component(props, secondArg); return children; } LazyComponent # function mountLazyComponent( _current, workInProgress, elementType, renderLanes ) { const props = workInProgress.pendingProps; const lazyComponent: LazyComponentType\u0026lt;any, any\u0026gt; = elementType; const payload = lazyComponent._payload; const init = lazyComponent._init; let Component = init(payload); workInProgress.type = Component; const resolvedTag = (workInProgress.tag = resolveLazyComponentTag(Component)); const resolvedProps = resolveDefaultProps(Component, props); let child; switch (resolvedTag) { case FunctionComponent: { // 具体流程在对应case中梳理 } case ClassComponent: { // ... } // ... } } // 该方法会在 renderWidthHook 中执行,后在 遍历到 lazy 组件时 执行 init 初始化组件 // 后续更新 则走 对应分支 export function lazy\u0026lt;T\u0026gt;( ctor: () =\u0026gt; Thenable\u0026lt;{default: T, ...}\u0026gt;, ): LazyComponent\u0026lt;T, Payload\u0026lt;T\u0026gt;\u0026gt; { const payload: Payload\u0026lt;T\u0026gt; = { // We use these fields to store the result. _status: Uninitialized, _result: ctor, }; const lazyType: LazyComponent\u0026lt;T, Payload\u0026lt;T\u0026gt;\u0026gt; = { $$typeof: REACT_LAZY_TYPE, _payload: payload, _init: lazyInitializer, }; return lazyType; } function lazyInitializer\u0026lt;T\u0026gt;(payload: Payload\u0026lt;T\u0026gt;): T { if (payload._status === Uninitialized) { const ctor = payload._result; // 执行异步加载方法 （一般是 import()） const thenable = ctor(); thenable.then( moduleObject =\u0026gt; { // 同步 lazy 组件 的状态与加载结果 if (payload._status === Pending || payload._status === Uninitialized) { // Transition to the next state. payload._status = Resolved; payload._result = moduleObject; } }, error =\u0026gt; { if (payload._status === Pending || payload._status === Uninitialized) { // Transition to the next state. payload._status = Rejected; payload._result = error; } }, ); if (payload._status === Uninitialized) { // 首次进来时改为 Pending 状态 const pending: PendingPayload = (payload: any); pending._status = Pending; pending._result = thenable; } } if (payload._status === Resolved) { // 如果 promise 完成了，那么会将加载的模块返回 const moduleObject = payload._result; return moduleObject.default; } else { // 第一次加载时，报错 throw payload._result; } } HostComponent # const isDirectTextChild = shouldSetTextContent(type, nextProps); // \u0026hellip; reconcileChildren(current, workInProgress, nextChildren, renderLanes);\nSuspenseComponent # TODO 后续补充\nHostPortal # function updatePortalComponent( current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes ) { // 在它的子节点被添加时，可以找到这个containerInfo节点。 // 这样就可以达到fiber在rootFiber内，但是添加的真实节点在其他节点的目的 pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo); const nextChildren = workInProgress.pendingProps; reconcileChildren(current, workInProgress, nextChildren, renderLanes); return workInProgress.child; } export function createPortal( children: ReactNodeList, containerInfo: any, implementation: any, key: ?string = null ): ReactPortal { return { $$typeof: REACT_PORTAL_TYPE, key: key == null ? null : \u0026#34;\u0026#34; + key, children, containerInfo, implementation }; } export function createFiberFromPortal( portal: ReactPortal, mode: TypeOfMode, lanes: Lanes ): Fiber { const pendingProps = portal.children !== null ? portal.children : []; const fiber = createFiber(HostPortal, pendingProps, portal.key, mode); fiber.lanes = lanes; fiber.stateNode = { containerInfo: portal.containerInfo, pendingChildren: null, // Used by persistent updates implementation: portal.implementation }; return fiber; } # ","date":"2025-01-18","externalUrl":null,"permalink":"/notes/react/beginwork_update/","section":"Notes","summary":"聚焦 beginwork 中针对 不同的 tag 具体实现逻辑","title":"React18 阅读笔记 -- BeginWork case 梳理","type":"notes"},{"content":"","date":"2025-01-18","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"// path: packages/react-reconciler/src/ReactFiberCompleteWork.old.js function completeWork( current: Fiber | null, workInProgress: Fiber, renderLanes: Lanes ): Fiber | null { switch (workInProgress.tag) { case IndeterminateComponent: case LazyComponent: case SimpleMemoComponent: case FunctionComponent: case ForwardRef: case Fragment: case Mode: case Profiler: case ContextConsumer: case MemoComponent: bubbleProperties(workInProgress); return null; case HostText: { // ...省略部分代码 // 根据不同tag 为 stateNode 创建 对应dom 节点 workInProgress.stateNode = createTextInstance( newText, rootContainerInstance, // root currentHostContext, workInProgress ); // 将所有child 的 return赋值为 completedWork； // 计算 completedWork 的 subtreeFlags bubbleProperties(workInProgress); return null; } case HostComponent: { // 将当前 fiber 移出 fiberStack popHostContext(workInProgress); // 在beginWork中对于HostRoot和HostPortal节点都会将真实节点container全 // 局存储到rootInstanceStackCursor.current，而在completeWork阶段将其移出。 // 在访问子节点时就能正确获取到它所在的容器 // 获取的是当前的 RootHostContainer const rootContainerInstance = getRootHostContainer(); const type = workInProgress.type; if (current !== null \u0026amp;\u0026amp; workInProgress.stateNode != null) { // // 如果真实节点存在，那么进行更新 updateHostComponent( current, workInProgress, type, newProps, rootContainerInstance ); } else { if (!newProps) { bubbleProperties(workInProgress); return null; } const currentHostContext = getHostContext(); const instance = createInstance( type, newProps, rootContainerInstance, currentHostContext, workInProgress ); // 将能渲染的子节点全部添加到当前创建的节点instance上 appendAllChildren(instance, workInProgress, false, false); workInProgress.stateNode = instance; } bubbleProperties(workInProgress); return null; } } } export function updateHostComponent() { // ... // 类似结构：[\u0026#39;name\u0026#39;, \u0026#39;张三\u0026#39;, \u0026#39;id\u0026#39;, 333, \u0026#39;style\u0026#39;, { color: \u0026#39;red\u0026#39; }] const updatePayload = prepareUpdate( instance, type, oldProps, newProps, rootContainerInstance, currentHostContext, ); workInProgress.updateQueue = (updatePayload: any); // 标记为 Update if (updatePayload) { markUpdate(workInProgress); } }; export function createInstance( type: string, props: Props, rootContainerInstance: Container, hostContext: HostContext, internalInstanceHandle: Object ): Instance { // 创建了 element const domElement: Instance = createElement( type, props, rootContainerInstance, parentNamespace ); // 建立关系 node . \u0026#39;__reactFiber$\u0026#39; + randomKey = fiber precacheFiberNode(internalInstanceHandle, domElement); // 建立关系 node . \u0026#39;__reactProps$\u0026#39; + randomKey = props updateFiberProps(domElement, props); return domElement; } ","date":"2025-01-18","externalUrl":null,"permalink":"/notes/react/completework/","section":"Notes","summary":"workloop 的 归 阶段， 根据已经创建/更新 好的 fiber 开始构建真实dom，TODO:有时间需要再梳理一下","title":"React18 阅读笔记 -- completeWork","type":"notes"},{"content":" 入口 # // path: packages/react-reconciler/src/ReactFiberBeginWork.old.js beginWork = (current, unitOfWork, lanes) =\u0026gt; { didReceiveUpdate = false; workInProgress.lanes = NoLanes; // 一大堆switch case 单独放在下一个文件中整理 // 这里只处理了 unitOfWork 为 hostRoot 的case return updateHostRoot(current, workInProgress, renderLanes); }; function updateHostRoot(current, workInProgress, renderLanes) { pushHostRootContext(workInProgress); // 将 current 的 UpdateQueue 拷贝给 workInProgress cloneUpdateQueue(current, workInProgress); /** * 将当前将要进行的更新 shared.pending 的环形链表，拆开拼接到到 lastBaseUpdate 的后面； * 执行 firstBaseUpdate 链表的操作时，若当前 update 对应的任务的优先级符合要求，则执行； * 若优先级较低，则存储执行到当前节点的状态，做为下次渲染时的初始值，和接下来所有的 update 节点； * 将执行所有操作后得到的 newState 重新给到 workInProgress.memoizedState； * 然后存储刚才淘汰下来的低优先级任务的链表，以便下次更新； */ processUpdateQueue(workInProgress, nextProps, null, renderLanes); const nextState: RootState = workInProgress.memoizedState; const root: FiberRoot = workInProgress.stateNode; const nextChildren = nextState.element; reconcileChildren(current, workInProgress, nextChildren, renderLanes); return workInProgress.child; } reconcileChildren # // export const reconcileChildFibers = ChildReconciler(true); // export const mountChildFibers = ChildReconciler(false); // 该初始化参数b表示是否有 current ,未在 reconcileChildFibers 中使用 function reconcileChildren( current: Fiber | null, workInProgress: Fiber, nextChildren: any, renderLanes: Lanes ) { if (current === null) { // mountChildFibers 也就是初始化 ChildReconciler 后 执行 reconcileChildFibers workInProgress.child = mountChildFibers( workInProgress, null, nextChildren, renderLanes ); // 更新阶段 } else { workInProgress.child = reconcileChildFibers( workInProgress, current.child, nextChildren, renderLanes ); } } reconcileChildFibers # // path: packages/react-reconciler/src/ReactChildFiber.old.js // 根据 newChild.$$typeof 不同类型 创建 fiber function reconcileChildFibers( returnFiber: Fiber, currentFirstChild: Fiber | null, newChild: any, lanes: Lanes ): Fiber | null { if (typeof newChild === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; newChild !== null) { switch (newChild.$$typeof) { case REACT_ELEMENT_TYPE: // react.element return placeSingleChild( // 调用 createFiberFromElement 为child 创建 fiber reconcileSingleElement( returnFiber, currentFirstChild, newChild, lanes ) ); case REACT_LAZY_TYPE: // react.lazy const payload = newChild._payload; const init = newChild._init; // TODO: This function is supposed to be non-recursive. return reconcileChildFibers( returnFiber, currentFirstChild, // _init: lazyInitializer, 具体实现 放在 update 中梳理 init(payload), lanes ); case REACT_PORTAL_TYPE: // react.portal return placeSingleChild( reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes) ); } // child有多个 if (isArray(newChild)) { return reconcileChildrenArray( returnFiber, currentFirstChild, newChild, lanes ); } throwOnInvalidObjectType(returnFiber, newChild); } } REACT_ELEMENT_TYPE # 当类型为 react.element 时，会先调用 reconcileSingleElement 方法，校验 key 和 type 是否一致，如果一致则使用 useFiber 方法进行复用 fiber。然后 调用 placeSingleChild 根据 current 与 当前 finber.alternate 判断是否需要给 fiber.flages 标记为新增\nfunction reconcileSingleElement( returnFiber: Fiber, currentFirstChild: Fiber | null, element: ReactElement, lanes: Lanes ): Fiber { const key = element.key; let child = currentFirstChild; while (child !== null) { // key 一致 直接复用 if (child.key === key) { const elementType = element.type; if (elementType === REACT_FRAGMENT_TYPE) { if (child.tag === Fragment) { // 如果是 Fragment 标签 则跳过直接复用 Fragment 的 children deleteRemainingChildren(returnFiber, child.sibling); const existing = useFiber(child, element.props.children); existing.return = returnFiber; return existing; } } else { deleteRemainingChildren(returnFiber, child.sibling); const existing = useFiber(child, element.props); existing.ref = coerceRef(returnFiber, child, element); existing.return = returnFiber; return existing; } // Didn\u0026#39;t match. // 遍历所有子节点 将 child 加入 fiber.deletions 并将 renturnFiber.flags 标记为 ChildDeletion deleteRemainingChildren(returnFiber, child); break; } else { deleteChild(returnFiber, child); } child = child.sibling; } // 否则直接新建fiber if (element.type === REACT_FRAGMENT_TYPE) { const created = createFiberFromFragment( element.props.children, returnFiber.mode, lanes, element.key ); created.return = returnFiber; return created; } else { const created = createFiberFromElement(element, returnFiber.mode, lanes); created.ref = coerceRef(returnFiber, currentFirstChild, element); created.return = returnFiber; return created; } } function placeSingleChild(newFiber: Fiber): Fiber { if (shouldTrackSideEffects \u0026amp;\u0026amp; newFiber.alternate === null) { newFiber.flags |= Placement; } return newFiber; } REACT_LAZY_TYPE # reconcileChildrenArray # function reconcileChildrenArray( returnFiber: Fiber, currentFirstChild: Fiber | null, newChildren: Array\u0026lt;*\u0026gt;, lanes: Lanes ): Fiber | null { let resultingFirstChild: Fiber | null = null; let previousNewFiber: Fiber | null = null; // oldFiber 是老 fiber 的第一个 child，可以通过 sibling 进行遍历。 let oldFiber = currentFirstChild; // lastPlacedIndex 表示最后一个老fiber被复用的位置 let lastPlacedIndex = 0; // 表示新 ReactElement 的位置 let newIdx = 0; // 表示下一个老fiber let nextOldFiber = null; // Diff 算法，标记子节点中需要的操作，记录在 flags 中 // 这个位置相当于只对比了前面的一部分， // 如果出现 key 和 type 不一致的情况，那么会跳出对比。 for (; oldFiber !== null \u0026amp;\u0026amp; newIdx \u0026lt; newChildren.length; newIdx++) { if (oldFiber.index \u0026gt; newIdx) { // 一直找到 oldFiber index 与 newIdx 相等的节点 // 否则的话，oldFiber 不向后遍历。 nextOldFiber = oldFiber; oldFiber = null; } else { // 遍历下一个 fiber nextOldFiber = oldFiber.sibling; } // 这里的 newChildren 是 jsx 解析出来的 children，为 ReactElement节点 // 根据节点类型创建或者更新 fiber const newFiber = updateSlot( returnFiber, oldFiber, newChildren[newIdx], lanes ); if (newFiber === null) { // key 或 type 不相同时，不可复用。 // 此时 newFiber 为 null，对比就会终止。 // 这就意味着找到了第一个无法复用的节点 if (oldFiber === null) { oldFiber = nextOldFiber; } break; } // 更新时 需要标记 if (shouldTrackSideEffects) { if (oldFiber \u0026amp;\u0026amp; newFiber.alternate === null) { // 将老的fiber 添加 ChildDeletion 标记 deleteChild(returnFiber, oldFiber); } } // 取 current.index 和 lastPlacedIndex 最大值 // 并给 newFiber.flag 添加 Placement / Forked 标记 lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx); // 建立 newFiber 之间的联系 if (previousNewFiber === null) { resultingFirstChild = newFiber; } else { previousNewFiber.sibling = newFiber; } previousNewFiber = newFiber; oldFiber = nextOldFiber; } // 遍历跳出之后，会判断老fiber或者是新ReactElement遍历完成没。 // 如果 newChildren 遍历完成，那么所有剩余的老fiber都应该标记为删除 if (newIdx === newChildren.length) { // 标记删除，记录到 父 fiber 的 deletions 属性中 deleteRemainingChildren(returnFiber, oldFiber); return resultingFirstChild; } // 如果老fiber遍历完成，那么所有剩余新的ReactElement都是新插入的节点，创建newFiber if (oldFiber === null) { for (; newIdx \u0026lt; newChildren.length; newIdx++) { // 根据 ReactElement 创建 fiber const newFiber = createChild(returnFiber, newChildren[newIdx], lanes); if (newFiber === null) { continue; } // 为 newFiber.flage 添加 place 标记 lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx); if (previousNewFiber === null) { // TODO: Move out of the loop. This only happens for the first run. resultingFirstChild = newFiber; } else { previousNewFiber.sibling = newFiber; } previousNewFiber = newFiber; } return resultingFirstChild; } // 后续的是因为 key 和 type 不一致导致没有遍历完的数组。 // 此时开始复用的算法。 // 首先将老节点转换为 map 形式：{ key|index : fiber } const existingChildren = mapRemainingChildren(returnFiber, oldFiber); for (; newIdx \u0026lt; newChildren.length; newIdx++) { // 从 existingChildren 中匹配 newIdx / newChild.key， // 若匹配到 则调用 useFiber 复用拿出存储的 oldFiber // 否则创建 新fiber const newFiber = updateFromMap( existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes ); if (newFiber !== null) { if (shouldTrackSideEffects) { if (newFiber.alternate !== null) { // 如果已经复用了，在 map 中删除对应的 fiber existingChildren.delete( newFiber.key === null ? newIdx : newFiber.key ); } } // 能复用时，更新最后一个复用的 老fiber 的 index lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx); if (previousNewFiber === null) { resultingFirstChild = newFiber; } else { previousNewFiber.sibling = newFiber; } previousNewFiber = newFiber; } } if (shouldTrackSideEffects) { // 将所有没有被复用的老fiber标记为删除 existingChildren.forEach((child) =\u0026gt; deleteChild(returnFiber, child)); } return resultingFirstChild; } // 用于 diff 算法，标记最后匹配的 old fiber 的位置 function placeChild( newFiber: Fiber, lastPlacedIndex: number, newIndex: number ): number { newFiber.index = newIndex; // 当父亲的 current 不存在时，此时为 mount，shouldTrackSideEffects 为 false，不用做处理。 // 当父亲的 current 存在时，shouldTrackSideEffects 为 true。 // 例如，当遇到第一个需要重新创建的节点时，它对应的 parent 的 current 存在，标记为更新。 // 当遍历到子节点时，由于子节点对应的 parent 的 current 不存在，此时不标记更新。 // 这样做的好处是，只有父亲被标记为更新，而其后代均不作标记。 // 在 completeWork 的时候子节点直接全添加到父亲上。 // 在 commit 的时候只需要将父亲添加到 根节点上即可。 if (!shouldTrackSideEffects) { return lastPlacedIndex; } // 如果复用了 老fiber const current = newFiber.alternate; if (current !== null) { const oldIndex = current.index; // 如果老的 index \u0026lt; lastPlacedIndex，说明这些老的节点无法复用。 if (oldIndex \u0026lt; lastPlacedIndex) { // 不可复用，需要替换 newFiber.flags |= Placement; return lastPlacedIndex; } else { // This item can stay in place. // 否则说明这个老节点可以复用，返回老节点 index return oldIndex; } } else { // 如果 老 fiber不存在，那么需要替换 // 注意这里被标记了，commit的时候会进行处理 newFiber.flags |= Placement; return lastPlacedIndex; } } ","date":"2025-01-17","externalUrl":null,"permalink":"/notes/react/beginwork_create/","section":"Notes","summary":"聚焦 react fiber 调度的单元 beginWork 大致梳理其如何创建/更新/diff fiber 的","title":"React18 阅读笔记 -- beginwork fiber","type":"notes"},{"content":" commitRoot # beginWork 和 completeWork 阶段都正常结束后，此时所有的 fiber 和真实节点创建完成，进入到 commit 阶段：\nfinishConcurrentRender(root, exitStatus, lanes) { switch (exitStatus) { case RootCompleted: { // The work completed. Ready to commit. commitRoot( root, workInProgressRootRecoverableErrors, workInProgressTransitions, ) break; } } } function commitRoot(root) { const previousUpdateLanePriority = getCurrentUpdatePriority(); const prevTransition = ReactCurrentBatchConfig.transition; try { ReactCurrentBatchConfig.transition = 0; // 优先级为同步，不可被打断 setCurrentUpdatePriority(DiscreteEventPriority); commitRootImpl(root, previousUpdateLanePriority); } finally { ReactCurrentBatchConfig.transition = prevTransition; setCurrentUpdatePriority(previousUpdateLanePriority); } return null; } function commitRootImpl( root: FiberRoot, recoverableErrors: null | Array\u0026lt;CapturedValue\u0026lt;mixed\u0026gt;\u0026gt;, transitions: Array\u0026lt;Transition\u0026gt; | null, renderPriorityLevel: EventPriority ) { do { flushPassiveEffects(); } while (rootWithPendingPassiveEffects !== null); const finishedWork = root.finishedWork; const lanes = root.finishedLanes; root.finishedWork = null; root.finishedLanes = NoLanes; root.callbackNode = null; root.callbackPriority = NoLane; // 如果flags/subtreeFlags中存在PassiveMask，即Passive|ChildDeletion， // 那么 rootDoesHavePassiveEffects 为true。也就是说如果使用了useEffect或者是节点有删除的情况 // 那么就会执行flushPassiveEffects方法： if ( (finishedWork.subtreeFlags \u0026amp; PassiveMask) !== NoFlags || (finishedWork.flags \u0026amp; PassiveMask) !== NoFlags ) { if (!rootDoesHavePassiveEffects) { rootDoesHavePassiveEffects = true; // 异步执行 useEffect scheduleCallback(NormalSchedulerPriority, () =\u0026gt; { flushPassiveEffects(); return null; }); } } // 如果subtreeHasEffects或rootHasEffect存在，说明有更新。 // 首先会进入beforeMutation阶段，调用commitBeforeMutationEffects方法： if (subtreeHasEffects || rootHasEffect) { const shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects( root, finishedWork ); } commitMutationEffects(root, finishedWork, lanes); // 同步执行 useLayoutEffect 的 create 并存储 destroy commitLayoutEffects(finishedWork, root, lanes); if (rootDoesHavePassiveEffects) { rootDoesHavePassiveEffects = false; rootWithPendingPassiveEffects = root; pendingPassiveEffectsLanes = lanes; } root.current = finishedWork; // 如果还有未完成的更新，即优先级不够的更新，那么这里会被继续调度进行更新。 ensureRootIsScheduled(root, now()); // 如果当前更新中包含useEffect，并且lanes中含有同步lane，那么需要立即执行flushPassiveEffect // 相比于schedule执行flushPassiveEffects，这里执行更靠前。 if ( includesSomeLane(pendingPassiveEffectsLanes, SyncLane) \u0026amp;\u0026amp; root.tag !== LegacyRoot ) { flushPassiveEffects(); } flushSyncCallbacks(); return null; } // flushPassiveEffects export function flushPassiveEffects(): boolean { // 如果 rootWithPendingPassiveEffects 存在，说明使用了 useEffect 或者有子节点被删除 if (rootWithPendingPassiveEffects !== null) { const renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes); const priority = lowerEventPriority(DefaultEventPriority, renderPriority); const prevTransition = ReactCurrentBatchConfig.transition; const previousPriority = getCurrentUpdatePriority(); try { // transition 置为 0 ReactCurrentBatchConfig.transition = 0; // 设置 update 优先级，获取 lane 的时候会用得到 setCurrentUpdatePriority(priority); return flushPassiveEffectsImpl(); } finally { setCurrentUpdatePriority(previousPriority); ReactCurrentBatchConfig.transition = prevTransition; } } return false; } function flushPassiveEffectsImpl() { if (rootWithPendingPassiveEffects === null) { return false; } // 针对 fiber.flags === ChildDeletion 的 节点 执行 // commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor); // 对 function 组件 通过调用 // safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy); // 方法 执行 destroy。然后在 // commitPassiveUnmountEffectsInsideOfDeletedTree_complete // 方法中删除fiber引用并且删除对应真实节点的引用 // 到底后 执行 commitPassiveUnmountInsideDeletedTreeOnFiber 自下而上处理兄弟节点 commitPassiveUnmountEffects(root.current); // 同上步骤 调用effects里的 create 方法并生成destroy commitPassiveMountEffects(root, root.current, lanes, transitions); flushSyncCallbacks(); } // BeforeMutationEffects 阶段 export function commitBeforeMutationEffects( root: FiberRoot, firstChild: Fiber ) { focusedInstanceHandle = prepareForCommit(root.containerInfo); nextEffect = firstChild; commitBeforeMutationEffects_begin(); // 。。。省略部分代码 } function commitBeforeMutationEffects_begin() { // 向下遍历，直到找到一个不符合BeforeMutationMask的节点 while (nextEffect !== null) { const fiber = nextEffect; const child = fiber.child; // export const BeforeMutationMask = Update | Snapshot if ( (fiber.subtreeFlags \u0026amp; BeforeMutationMask) !== NoFlags \u0026amp;\u0026amp; child !== null ) { child.return = fiber; nextEffect = child; } else { commitBeforeMutationEffects_complete(); } } } // 自下往上遍历，执行 commitBeforeMutationEffectsOnFiber function commitBeforeMutationEffects_complete() { while (nextEffect !== null) { const fiber = nextEffect; // 处理 class组件中定义的getSnapshotBeforeUpdate函数 // 或者 处理 current === null || current.child === null 的HostRoot // 将 root.containerInfo 真实节点的内容置空 commitBeforeMutationEffectsOnFiber(fiber); const sibling = fiber.sibling; if (sibling !== null) { sibling.return = fiber.return; nextEffect = sibling; return; } nextEffect = fiber.return; } } // mutation 阶段 export function commitMutationEffects( root: FiberRoot, finishedWork: Fiber, committedLanes: Lanes ) { inProgressLanes = committedLanes; inProgressRoot = root; // mutation阶段的执行顺序也是自上而下开始遍历，执行删除dom操作，然后到了最底层子节点， // 开始自下而上执行插入和更新dom操作 commitMutationEffectsOnFiber(finishedWork, root, committedLanes); inProgressLanes = null; inProgressRoot = null; } function commitMutationEffectsOnFiber( finishedWork: Fiber, root: FiberRoot, lanes: Lanes ) { const current = finishedWork.alternate; const flags = finishedWork.flags; // The effect flag should be checked *after* we refine the type of fiber, // because the fiber tag is more specific. An exception is any flag related // to reconcilation, because those can be set on all fiber types. switch (finishedWork.tag) { case FunctionComponent: case ForwardRef: case MemoComponent: case SimpleMemoComponent: { // Deletion 深度遍历执行删除操作 recursivelyTraverseMutationEffects(root, finishedWork, lanes); // Placement 插入逻辑 commitReconciliationEffects(finishedWork); if (flags \u0026amp; Update) { // 找出 useInsertionEffect 的 destroy 方法去调用 // 需要注意 destroy 可能为 undefined（函数组件初次挂载的情况下） commitHookEffectListUnmount( HookInsertion | HookHasEffect, finishedWork, finishedWork.return, ); // 执行 useInsertionEffect 的回调函数，并将返回值保存到 effect.destory 里。 commitHookEffectListMount( HookInsertion | HookHasEffect, finishedWork, ); if ( enableProfilerTimer \u0026amp;\u0026amp; enableProfilerCommitHooks \u0026amp;\u0026amp; finishedWork.mode \u0026amp; ProfileMode ) { startLayoutEffectTimer(); // useLayoutEffect 对应的 destroy 方法 // 同样可能不存在 commitHookEffectListUnmount( HookLayout | HookHasEffect, finishedWork, finishedWork.return, ); recordLayoutEffectDuration(finishedWork); } } return; } case HostComponent: { recursivelyTraverseMutationEffects(root, finishedWork, lanes); commitReconciliationEffects(finishedWork); } } 流程图 # commit 流程图 ","date":"2025-01-17","externalUrl":null,"permalink":"/notes/react/commit/","section":"Notes","summary":"commit阶段 处理 fiber 创建/更新 遗留的 副作用 值得一提的是 useEffect 在该阶段会通过 microTask 方式放到微任务队列等待当前同步代码执行完成后再执行","title":"React18 阅读笔记 -- commit","type":"notes"},{"content":"\u003c!DOCTYPE html\u003e Document 2222 ","date":"2025-01-13","externalUrl":null,"permalink":"/posts/","section":"","summary":"","title":"","type":"posts"},{"content":"sadasdas\n","date":"2025-01-13","externalUrl":null,"permalink":"/posts/test2/","section":"","summary":"","title":"Test2","type":"posts"},{"content":" New article! ReactDOM.createRoot # 创建了一个 reactfiberrootnode current 属性指向一个新 fiber,并绑定所有事件监听\n/** * 创建 tag = 1 的 FiberRoot 对象 * 并在current 上挂载了一个 tag = 3, mode = 1 的空fiber * 初始化该 fiber 的 UpdateQueue initializeUpdateQueue(uninitializedFiber) */ const root = createContainer( container, ConcurrentRoot, // 常量 1 null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks, ); // container[__reactContainer$(一串随机数)] = root.current; markContainerAsRoot(root.current, container); const rootContainerElement: Document | Element | DocumentFragment = container.nodeType === COMMENT_NODE ? (container.parentNode: any) : container; /** 为 container 添加事件监听 */ listenToAllSupportedEvents(rootContainerElement); /** * this._internalRoot = internalRoot; * 挂载到 ReactDOMRoot._internalRoot 属性上 */ return new ReactDOMRoot(root); react # // path: packages/react-dom/src/client/ReactDomRoot.js ReactDOMRoot.prototype.render = function (children: ReactNodeList): void { // ...省略部分代码 updateContainer(children, root, null, null); }; // path: packages/react-reconciler/src/ReactFiberReconciler.old.js function updateContainer( element: ReactNodeList, // Index container: OpaqueRoot, // root parentComponent: ?React$Component\u0026lt;any, any\u0026gt;, // null callback: ?Function // null ): Lane { // 初始化一个 update 任务 const update = createUpdate(eventTime, lane); update.payload = { element }; /** * 将创建的 update任务 添加到 ReactFiberConcurrentUpdates 文件 * 全局变量 concurrentQueues 中 * 用传入的 lane 更新fiber链表中的所有 lane 并返回 root * */ const fiber = container.current; const queue: SharedQueue\u0026lt;State\u0026gt; = fiber.updateQueue.shared; const interleaved = queue.interleaved; if (interleaved === null) { update.next = update; ReactFiberConcurrentUpdates.concurrentQueues = [queue]; } queue.interleaved = update; // 上面是 enqueueUpdate 方法的具体实现 执行栈太长就把重要步骤挪过来方便查看了 const root = markUpdateLaneFromFiberToRoot(fiber, lane); if (root !== null) { scheduleUpdateOnFiber(root, current, lane, eventTime); entangleTransitions(root, current, lane); } } // path: packages/react-reconciler/src/ReactFiberWorkLoop.old.js function scheduleUpdateOnFiber( root: FiberRoot, fiber: Fiber, lane: Lane, eventTime: number ) { // 将 eventTime 按 lane 插入到 root.eventTimes 中 markRootUpdated(root, lane, eventTime); // 做的事情蛮多 ensureRootIsScheduled(root, eventTime); } // ensureRootIsScheduled function ensureRootIsScheduled(root: FiberRoot, currentTime: number) { //根据 root.eventTimes 计算出 root.expirationTimes markRootUpdated(root, lane, eventTime); const nextLanes = getNextLanes(root, NoLanes); const newCallbackPriority = getHighestPriorityLane(nextLanes); const existingCallbackNode = root.callbackNode; if (existingCallbackNode != null) { // Cancel the existing callback. We\u0026#39;ll schedule a new one below. cancelCallback(existingCallbackNode); } let newCallbackNode = scheduleCallback( schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root) ); root.callbackPriority = newCallbackPriority; root.callbackNode = newCallbackNode; } function scheduleCallback(priorityLevel, callback) { // 这里调用的就是 Scheduler 中的 unstable_scheduleCallback 方法 return Scheduler_scheduleCallback(priorityLevel, callback); } // path: packages/scheduler/src/forks/Scheduler.js function unstable_scheduleCallback(priorityLevel, callback, options) { var currentTime = getCurrentTime(); var startTime = currentTime; // NormalPriority 是 5000 var timeout = 5000; var expirationTime = startTime + timeout; var newTask = { id: taskIdCounter++, callback, // performConcurrentWorkOnRoot 方法 priorityLevel, startTime, expirationTime, sortIndex: -1 }; newTask.sortIndex = expirationTime; // 将 newTask 放进 taskQueue 并按照 sortIndex 排序 push(taskQueue, newTask); // 挂载时都为初始值 false if (!isHostCallbackScheduled \u0026amp;\u0026amp; !isPerformingWork) { isHostCallbackScheduled = true; function requestHostCallback(callback) { scheduledHostCallback = callback; // 挂载时都为初始值 false if (!isMessageLoopRunning) { isMessageLoopRunning = true; // 通过 postMessage 异步调用 performWorkUntilDeadline schedulePerformWorkUntilDeadline(); } } requestHostCallback(flushWork); } } // path: packages/scheduler/src/forks/Scheduler.js const performWorkUntilDeadline = () =\u0026gt; { const currentTime = getCurrentTime(); let hasMoreWork = true; try { // 这里的 scheduledHostCallback 就是 flushWork hasMoreWork = scheduledHostCallback(true, currentTime); } finally { // 还有任务则再调一轮 if (hasMoreWork) { schedulePerformWorkUntilDeadline(); } else { isMessageLoopRunning = false; scheduledHostCallback = null; } } }; // path: packages/scheduler/src/forks/Scheduler.js // hasTimeRemaining = true ,initialTime = currentTime function flushWork(hasTimeRemaining, initialTime) { isHostCallbackScheduled = false; isPerformingWork = true; // 这里的 currentPriorityLevel 为初始值 3 const previousPriorityLevel = currentPriorityLevel; try { return workLoop(hasTimeRemaining, initialTime); } finally { currentTask = null; currentPriorityLevel = previousPriorityLevel; isPerformingWork = false; if (enableProfiling) { const currentTime = getCurrentTime(); markSchedulerSuspended(currentTime); } } } // path: packages/scheduler/src/forks/Scheduler.js function workLoop(hasTimeRemaining, initialTime) { let currentTime = initialTime; currentTask = peek(taskQueue); while (currentTask !== null) { // 这里的 callback 就是 performConcurrentWorkOnRoot const callback = currentTask.callback; if (typeof callback === \u0026#34;function\u0026#34;) { currentTask.callback = null; currentPriorityLevel = currentTask.priorityLevel; const didUserCallbackTimeout = currentTask.expirationTime \u0026lt;= currentTime; // 至此 任务调度 完成，开始执行任务 进入 reconciler 阶段 const continuationCallback = callback(didUserCallbackTimeout); currentTime = getCurrentTime(); if (typeof continuationCallback === \u0026#34;function\u0026#34;) { currentTask.callback = continuationCallback; } else { if (currentTask === peek(taskQueue)) { pop(taskQueue); } } } } } // path: packages/react-reconciler/src/ReactFiberWorkLoop.old.js function performConcurrentWorkOnRoot(root, didTimeout) { const originalCallbackNode = root.callbackNode; /** 刷新pending状态的effects, 有可能某些effect会取消本次任务 */ const didFlushPassiveEffects = flushPassiveEffects(); let lanes = getNextLanes(root, NoLanes); let exitStatus = renderRootSync(root, lanes); if (![0, 1, 2, 6].includes(exitStatus)) { root.finishedWork = finishedWork; root.finishedLanes = lanes; // !调和阶段完成 提交fiber树 finishConcurrentRender(root, exitStatus, lanes); } ensureRootIsScheduled(root, now()); // 若还是同一个任务则继续返回该任务 if (root.callbackNode === originalCallbackNode) { return performConcurrentWorkOnRoot.bind(null, root); } return null; } function renderRootSync(root: FiberRoot, lanes: Lanes) { // 存储 executionContext const prevExecutionContext = executionContext; // 将 executionContext 更新为 RenderContext executionContext |= RenderContext; ReactCurrentDispatcher.current = ContextOnlyDispatcher; // 如果workinprogress不存在 则初始化一个 // 并将 queue.interleaved 移到 queue.pending 中 // 这里的 queue 存的是 root.current.updateQueue.shared // 在 enqueueConcurrentClassUpdate 方法中给 queue.interleaved 赋值为 update; // 该update 是在 updateContainer 方法中 创建的 并将 payload属性赋值为了 render方法里的 第一个参数 prepareFreshStack(root, lanes); do { try { workLoopSync(); break; } catch (thrownValue) { handleError(root, thrownValue); } } while (true); return workInProgressRootExitStatus; } function workLoopSync() { while (workInProgress !== null) { performUnitOfWork(workInProgress); } } function performUnitOfWork(unitOfWork: Fiber): void { const current = unitOfWork.alternate; let next; // 用来存放beginWork()返回的结果 // 根据 workInProgress.tag 创建对应 fiber // 若 为 函数组件 则调用 renderWidthHook 执行函数组件 并 创建对应fiber next = beginWork(current, unitOfWork, subtreeRenderLanes); // 更新状态了 unitOfWork.memoizedProps = unitOfWork.pendingProps; if (next === null) { // If this doesn\u0026#39;t spawn new work, complete the current work. completeUnitOfWork(unitOfWork); } else { // 下次的workLoopSync/workLoopConcurrent的while循环的循环主体为子Fiber节点 workInProgress = next; } } function completeUnitOfWork(unitOfWork: Fiber): void { // 本次 performUnitOfWork 的循环主体 workInprogress 的最底层 child let completedWork = unitOfWork; do { const current = completedWork.alternate; const returnFiber = completedWork.return; // 只要 beginWork 阶段正常执行后（即执行无异常），都会进到这一段逻辑来 let next; next = completeWork(current, completedWork, subtreeRenderLanes); resetCurrentDebugFiberInDEV(); if (next !== null) { workInProgress = next; return; } // 取当前Fiber节点(completedWork)的兄弟(sibling)节点； // 如果有值，则结束completeUnitOfWork，并将该兄弟节点作为下次performUnitOfWork的主体(unitOfWork) const siblingFiber = completedWork.sibling; if (siblingFiber !== null) { // If there is more work to do in this returnFiber, do that next. workInProgress = siblingFiber; return; } // Otherwise, return to the parent // 若没有兄弟节点，则将在下次do...while循环中处理父节点(completedWork.return) completedWork = returnFiber; // Update the next thing we\u0026#39;re working on in case something throws. // 此处需要注意！ // 虽然把workInProgress置为completedWork，但由于没有return，即没有结束completeUnitOfWork，因此没有意义 // 直到completedWork（此时实际上是本循环中原completedWork.return）为null，结束do...while循环后 // 此时completeUnitOfWork的运行结果(workInProgress)为null // 也意味着performSyncWorkOnRoot/performConcurrentWorkOnRoot中的while循环也达到了结束条件 workInProgress = completedWork; } while (completedWork !== null); // We\u0026#39;ve reached the root. if (workInProgressRootExitStatus === RootInProgress) { workInProgressRootExitStatus = RootCompleted; } } finishConcurrentRender(root, exitStatus, lanes) { switch (exitStatus) { case RootCompleted: { // The work completed. Ready to commit. commitRoot( root, workInProgressRootRecoverableErrors, workInProgressTransitions, ) break; } } } function commitRootImpl( root: FiberRoot, recoverableErrors: null | Array\u0026lt;CapturedValue\u0026lt;mixed\u0026gt;\u0026gt;, transitions: Array\u0026lt;Transition\u0026gt; | null, renderPriorityLevel: EventPriority, ) { do { flushPassiveEffects() } while (rootWithPendingPassiveEffects !== null); const finishedWork = root.finishedWork; const lanes = root.finishedLanes; root.finishedWork = null; root.finishedLanes = NoLanes; root.callbackNode = null; root.callbackPriority = NoLane; if (!rootDoesHavePassiveEffects) { rootDoesHavePassiveEffects = true; pendingPassiveEffectsRemainingLanes = remainingLanes; pendingPassiveTransitions = transitions; scheduleCallback(NormalSchedulerPriority, () =\u0026gt; { flushPassiveEffects(); return null; }); } if (subtreeHasEffects || rootHasEffect) { const shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects( root, finishedWork, ); } } ","date":"2025-01-13","externalUrl":null,"permalink":"/notes/react/render%E8%B0%83%E5%BA%A6/","section":"Notes","summary":"从 render 入口函数 开始 debug react18 源码，梳理 主体流程 有哪些步骤","title":"React18 阅读笔记 -- render 调度阶段","type":"notes"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]